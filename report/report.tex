\documentclass[12pt]{report}

\usepackage[a4paper, margin=1.3in]{geometry}
\usepackage{biblatex}
\usepackage{setspace}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{mathtools}

\usepackage{algorithm}
\usepackage{algpseudocode}

% settings for amsthm package
% apply chapter-wise theorem numbering for theorems
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{proposition}[theorem]{Proposition}

% The following are the numbered elements with "definition (i.e. non-italic) style"
\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

% Load `.bib` file
\addbibresource{references.bib}

% Symbol definitions
\def\Consts{{\mathrm{Consts}}}
\def\Terms{{\mathrm{Terms}}}
\newcommand{\ASatRules}[1]{\ensuremath{\normalfont{\textsc{ASatRules}} \left( #1 \right)}}
\newcommand{\SCTree}[2]{\ensuremath{\normalfont{\textrm{SCTree}} \left( #1, #2 \right)}}

\title{Querying Infinite GTGD Chases}
\author{Ryosuke Kondo}
\date{May 2023}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

\section*{Abstract}

\newpage
\chapter{Introduction}

\section{Background}

Consider the following situation: (TODO; Think about some OMQA instance where two independent parties provide a data over which we would like to perform an existential join query.)

We would now like to find out (TODO; insert here the query content in English). This amounts to finding all \emph{answers} to a first-order existential sentence (TODO; insert here the query in first-order language), where each answer is a \emph{substitution} mapping free variables (TODO) to constants in data sources that make the sentence true.

Unlike querying a single relational database, it is not sufficient to perform a non-existential join query (TODO; insert here the query with existentials stripped away) and project the resulting tuples to ignore uninteresting components. Even though no constant in the input database matches variables in the partially-applied query (TODO; insert here a partially-applied query), we can deduce from the constraints that there must be some \emph{unknown} values that matches (TODO; insert here a partially-applied query).

In general, the problem of answering queries given (1) a collection of \emph{incomplete} data sources, (2) a finite set of \emph{data integration rules} that can derive the existence of new tuples and (3) a conjunctive query (CQ) is called Ontology-Mediated Query Answering (OMQA) \cite{bienvenu16}.

Data integration rules in OMQA problem instances are often written as Tuple-Generating Dependencies (TGDs), which are first-order sentences of the form $\forall \vec{x}. \Phi(\vec{x}, \vec{c}) \rightarrow \exists \vec{y}. \Psi(\vec{x}, \vec{y}, \vec{c}')$. In the example above, for instance, the rules can be translated into logical formulae (TODO: translate the rules into TGDs). Formulated this way, we can think of OMQA problems as finding all assignments $\sigma$ of free variables in the input query that validate the logical entailment relation $\mathcal{D} \land \Sigma \models \sigma(Q)$, where $\mathcal{D}$ is the conjunction of all records present in data sources, $\Sigma$ is the data integration rules and $Q$ is the input CQ.

Unfortunately, however, OMQA problems with general TGDs turned out to be undecidable \cite{beeri_vardi_1981}. In response to this, \cite{cali_gottlob_kifer_2013} identified \emph{Guarded TGDs} (GTGDs) as a subclass of TGDs that leaves OMQA problems decidable, yet expressive enough to contain several classes of description logics.

\section{Previous Works}

Despite OMQA problems over GTGDs being known to be decidable for several years, only a small number of work have been done to develop computationally tractable algorithms for these problems. A recent work \cite{kappelmann_2019} suggested that we can efficiently rewrite a set of GTGD rules into a so-called \emph{Datalog saturation} of it, which is a set of existential-free TGDs that is "equivalent" to the original rule set for existential-free queries. The rewriting algorithm has been improved, implemented and evaluated in \cite{benedikt_buron_germano_kappelmann_motik_2022}. 

(TODO: include a diagram indicating the scheme of how Datalog saturation is incorporated into OMQA)

Even though the implementation by \cite{benedikt_buron_germano_kappelmann_motik_2022} only supports atomic queries out-of-the-box, we can reduce any \emph{acyclic} existential queries into a few guarded rules and a single goal atom containing just the free variables in the original query. For the (TODO: reference to the example given at the beginning of Section 1.1) query, we can add a (TODO)-ary goal predicate $\mathrm{Goal}(-, -)$ and rules (TODO: apply the reduction). However, such reduction does not apply to cyclic queries (e.g. a \emph{triangle query} $\exists x,y,z. R(w, x, y) \land S(y, z) \land S(z, x)$) in general.

(TODO: The following two paragraphs clearly do not fit here, but I think they should be present in the introduction, or else the exact problem I worked on is very difficult to communicate. Reorganize?)

It has been known that the entailment $\mathcal{D} \land \Sigma \models \sigma(Q)$ holds if and only if $\sigma(Q)$ is witnessed by the \emph{chase} of $\mathcal{D}$, which, informally speaking, is the result of \emph{repairing} $\mathcal{D}$ by generating tuples using rules in $\Sigma$ infinitely many times. % citation needed

Moreover, it has also been known that there exists a \emph{Datalog rewriting} of a finite set of GTGD rules and an arbitrary CQ \cite{barany_benedikt_cate_2013}. We will refer the problem of finding a Datalog rewriting of a GTGD rule set and a CQ by \emph{GTGD-Datalog Rewriting}. Note that Datalog-saturating a GTGD rule set is a special case of GTGD-Datalog Rewriting problem where the query is always atomic.

\emph{To the best of my knowledge, however, no work has implemented a query answering procedure for general CQs under GTGDs}. Given that many real-world database queries are cyclic (TODO: evidence?), limiting ourselves to acyclic existential queries may pose issues on smooth adoptation of OMQA systems.

\section{Contribution of This Work}

The contribution of this work is threefold:

\begin{itemize}
  \item By examining the structure of chases, I derived a novel reduction of GTGD-Datalog Rewriting problem into exponentially many small instances of GTGD query answering problems with \emph{Boolean} CQs (BCQs), which no longer have free variables.
  \item By making use of properties of chases, I demonstrate how BCQ answering over GTGD rules can be decided using a simple product of two \emph{tree automata}. By eliminating redundant nondeterminism in these automata, I derived a novel recursive procedure for deciding BCQ entailment problems, which can be memoized to further speed up subsequent BCQ answerings.
  \item Last but not least, I provide a Java implementation of the former two algorithms which, when combined, can be assembled into an OMQA system.
\end{itemize}

\section{Outline of This Report}

(TODO: use in-doc links)

In Chapter 2, I introduce basic terminologies and results that will be used throughout the report.

In Chapter 3, I revisit the notion of "tree-like chase proof" and introduce the notion of "shortcut chases" (TODO: I'm pretty sure this have been defined elsewhere; find a literature if possible and cite here?) with a few diagrams. I then provide a simple analysis of how answers of the input query must be embedded into the chase tree, and argue that for rewriting purpose it is sufficient to decide whether a given rule plus a guarded set is "large enough" to entail a Boolean conjunctive subquery of a particular form.

In Chapter 4, I begin with introducing nondeterministic finitely-branching-tree automata. We then discuss the most natural way to decide BCQ entailment using a formal product of "wildly nondeterministic branching query automaton" and "naive chase automaton". I show that, by carefully balancing the role of these two automata, we can make the chase automaton deterministic, and argue that we can translate the so-obtained automaton into a recursive decision algorithm.

In Chapter 5, we discuss the details of implementation and its verification. I provide some benchmarks to observe how the algorithm runtime increases as the input becomes larger.

We conclude the report with an overview, and discuss some weakness of the algorithm which may be improved in future studies.

\newpage
\chapter{Preliminaries}

% TODO: define formula formalism
% TODO: define TGDs, Datalog rules, full TGDs, guarded TGDs
% TODO: define "instances", and make it clear that we may use a word "bag" in contexts where we don't talk about the whole database

\section{Datalog Saturation}

Consider the following problem:

\begin{problem}
   Given an existential free conjunctive query $Q$, an input database $\mathcal{D}$ and a Datalog program $P$, find all substitutions $\sigma: FV(Q) \rightarrow \Consts(\mathcal{D})$ such that $\mathcal{D}, P \models \sigma(Q)$.
\end{problem}

Several algorithms for this problem are known, and \cite{bancilhon_ramakrishnan_1986} compared a few classic algorithms. One of the simplest is the \emph{Naive Evaluation}. Roughly speaking, we keep adding tuples produced by rules in $P$ to the input database until we reach a fix-point. We then evaluate $Q$, which is merely a join query, on the populated database to obtain all answers.

\begin{algorithm}
\caption{Answering Datalog query using Naive Evaluation}
\begin{algorithmic}[1]
\Procedure{DatalogSaturate}{Datalog program $P$, input database $\mathcal{D}$}
  \State $\mathcal{D}_\mathrm{current} \gets \mathcal{D}$
  \While{true}
    \State $\mathcal{D}_\mathrm{next} \gets \mathcal{D}_\mathrm{current}$
    \ForAll{$r \in P$}
      \ForAll{$\sigma \in $ result of matching the body of $r$ on $\mathcal{D}_\mathrm{current}$}
        \State add all head atoms of $r$ substituted with $\sigma$ to $\mathcal{D}_\mathrm{next}$
      \EndFor
    \EndFor
    \State
    \If{$\mathcal{D}_\mathrm{next} \neq \mathcal{D}_\mathrm{current}$}
      \State $\mathcal{D}_\mathrm{next} \gets \mathcal{D}_\mathrm{current}$
    \Else
      \State \Return{$\mathcal{D}_\mathrm{current}$}
    \EndIf
  \EndWhile
\EndProcedure
\State
\Procedure{AnswerDatalogQuery}{$P$, $\mathcal{D}$, $\exists$-free query $Q$}
  \State \Return{result of running the join query $Q$ on $\textsc{DatalogSaturate}(P, \mathcal{D})$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

We call the database instance $\textsc{DatalogSaturate}(P, \mathcal{D})$ the \emph{Datalog saturation of $\mathcal{D}$ with $P$}. Intuitively, a Datalog saturation results from \emph{supplementing} the input instance by adding all but nothing other than facts derivable from the original instance.

\section{Problem Formulation}

% Define output of GSat as "atomic saturation" of a GTGD set
Our ultimate goal is to answer the following problem.

\begin{problem}[GTGD-CQ Answering]
\label{GTGD-CQ-Answering}
  Given a finite set $\Sigma$ of GTGD rules, a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j(\vec{u})$ and a base instance $\mathcal{D}$, what are the \emph{answers} to $Q$ under $\Sigma$ and $\mathcal{D}$, i.e. substitutions $\sigma: FV(Q) \rightarrow \Consts(\mathcal{D})$ such that $\mathcal{D}, \Sigma \models \sigma(Q)$?
\end{problem}

% Motivate why we want to compute Datalog rewritings by talking about data complexity, cite the result showing the existence and finally formally define.

It is known that a conjunctive query under GTGD rules admits \emph{Datalog rewritings} \cite{barany_benedikt_cate_2013}. These are Datalog programs with a designated \emph{goal atom} that, when run on any base instance, give the same set of answers as the original rule-query pair. More precisely:

\begin{definition}
  A \emph{Datalog rewriting} of a GTGD-CQ pair $(\Sigma, Q)$ is a Datalog program $\Sigma_\mathrm{Datalog}$ together with an atomic query $Q_\mathrm{atomic}$ such that for every base instance $\mathcal{D}$ and a substitution $\sigma: FV(Q) \rightarrow \Consts(\mathcal{D})$ for $Q$, $$\Sigma, \mathcal{D} \models \sigma(Q) \textit{ if and only if } \Sigma_\mathrm{Datalog}, \mathcal{D} \models \sigma(Q_\mathrm{atomic}).$$
  We call $Q_\mathrm{atomic}$ the \emph{goal atom} in the Datalog rewriting.
\end{definition}

This project aims to derive an algorithm that produces Datalog rewritings for arbitrary GTGD-CQ pairs.

\newpage
\chapter{Characterising Query Entailment under GTGDs}

\section{Tree-Like Chase Proofs}

In the settings of existential rules, an object known as the \emph{chase} represents the \emph{completion} of a database for some data integration rules. Chases are constructed similarly to Datalog saturations by adding tuples produced by rules, except we need to replace existential variables with \emph{nulls}, which represent fresh constants \cite{fagin_kolaitis_miller_popa_2005}.

As with Datalog saturations, chases over an instance $\mathcal{D}$ give all possible answers $\sigma: \vec{z} \rightarrow \Consts(\mathcal{D})$ to a conjunctive query $Q = \exists \vec{x}. \bigwedge_{j \in J} A_j$. That is, we can find all answers to $Q$ by evaluating a join query $\bigwedge_{j \in J} A_j$ on the chase and projecting $\vec{x}$ away.

However, in the presence of recursive rules such as $R(x, y) \rightarrow \exists z. R(y, z)$, the chase procedure may have to be continued indefinitely, producing an infinite chase. Moreover, due to how one constructs a chase, it lacks a structure with which we can reason about query entailments.

% TODO: which paper introduced tree-like chase proofs for Datalog+-?
To deal with this issue, \cite{benedikt_buron_germano_kappelmann_motik_2022} introduced the notion of \emph{tree-like chase proofs}, which essentially capture instants of ongoing chase processes.

\begin{definition}
  A \emph{chase tree} is a pair of a (potentially infinite) rooted directed tree $T$ together with a function $\mu$ mapping each vertex $v \in T$ to bags of facts (possibly with nulls).
\end{definition}

Chase trees can be infinite in general, but we focus on finite chase trees in this section. The following definition incorporates ideas from \cite{benedikt_buron_germano_kappelmann_motik_2022} and \cite{kappelmann_2019}.

% TODO: The notion of "chase transformation" is superfluous; we do not need to introduce a word for that and say that a chase proof evolves in one of two ways.
\begin{definition}
 Given a set $\Sigma$ of single-headed GTGD rules, a \emph{chase transformation over $\Sigma$} on a chase tree $(T, \mu)$ is one of the following transformations:
  \begin{itemize}
    \item \emph{a chase step} from a vertex $v \in T$ with $\tau = \forall \vec{x}. \beta \rightarrow \exists \vec{y}. H$ and a substitution $\sigma$ mapping $\vec{x}$ to constants in $\mu(v)$, provided that $\sigma(\beta) \subseteq \mu(v)$. The result $(T', \mu')$ of this step depends on whether $\tau$ is full, i.e. if $|\vec{y}| = 0$:
    \begin{itemize}
      \item If $\tau$ is full, we simply add the head atom $H$ of $\tau$ to the instance at $v$. That is, we keep $T' = T$, and set $\mu'(v) = \mu(v) \cup \sigma(H)$ while maintaining $\mu$ and $\mu'$ equal on $T \setminus \{v\}$.
      \item If $\tau$ is existential, we create a fresh child of $v$, put produced fact in it and \emph{inherit} facts from the parent instance. To do so, we first extend $\sigma$ to a substitution $\sigma'$ that maps variables in $\vec{y}$ to fresh nulls. We define the instance $I$ containing \emph{inherited facts} as $$I = \{ F \in \mu(v) \mid \Terms(f) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma) \}.$$ Finally, we prepare a fresh vertex $c$, form $T'$ by making $c$ a child of $v$, and extend $\mu$ to $\mu'$ with $\mu'(c) = \{\sigma'(H)\} \cup I$.
    \end{itemize}
    \item \emph{a propagation step} from a vertex $v \in T$ to an ancestor $a \in T$ of $v$ with a fact $f \in \mu(v)$, provided that $f \not\in \mu(a)$ and $\Terms(f) \subseteq \Terms(\mu(a)) \cup \Consts(\Sigma)$. The resulting chase tree is $(T, \mu')$, where $\mu'$ agrees with $\mu$ everywhere except at $a$, and $\mu'(a) = \mu(a) \cup \{f\}$.
  \end{itemize}
\end{definition}

\begin{definition}
\label{tree-like-chase-proof}
  Given a set $\Sigma$ of single-headed GTGD rules and a base instance $\mathcal{D}$, a \emph{tree-like chase proof over $\Sigma$ from $\mathcal{D}$} is a finite sequence of chase trees $C_1, \ldots, C_n$ such that
  \begin{itemize}
    \item $C_1 = (T, \mu)$ is a chase tree with a single vertex $v$ together with $\mu(v) = \mathcal{D}$.
    \item for each $i < n$, $C_{i + 1}$ is obtained from $C_i$ by applying a chase transformation over $\Sigma$.
  \end{itemize}
\end{definition}

A tree-like chase proof over $\Sigma$ from $\mathcal{D}$ represents a process of supplementing $\mathcal{D}$ according to $\Sigma$. We can derive new tuples by using a chase step, branching off to a child node when introducing nulls corresponding to existential values. With a propagation step, we can retrieve a fact derived at a descendant node to the ancestor node.

Note that we only propagate or inherit facts whose terms appear in the target node. Intuitively, such a restriction can be justified because the guardedness of rules in $\Sigma$ prohibits us from \emph{combining} unrelated terms into new tuples. We cannot hope to fire an existential rule from a node $a \in T$ in a meaningfully novel manner even if we transfer to $a$ a fact with terms not already present in $a$. That is, if we propagated a fact $F$ from $v$ to $a$ and could fire a rule $(\tau, \sigma)$ on $a$ \emph{using} $F$, we could have fired $(\tau, \sigma)$ on $v$ in the first place, provided that $v$ inherited enough facts related to $F$ from $a$\footnote{In fact, $a$ might have more facts with terms in $F$ than $v$ does due to propagation from cousin nodes of $v$. In that case, we could "re-derive" a cousin node $v'$ from $a$ in the same way as how $v$ had been derived, and $v'$ should have as many facts related to an isomorphic copy of $F$ as $a$ does.}.

The restriction mentioned above makes tree-like chase proofs locally compact in the following sense.

\begin{definition}
  Let $\Sigma$ be a set of GTGDs and $K \in \mathbb{N}$. We say that a bag $\mathcal{B}$ of facts is \emph{$(K, \Sigma)$-small} when $|\Terms(\mathcal{B}) \setminus \Consts(\Sigma)| \leq K$.
\end{definition}

\begin{proposition}[Tree-width of chase proofs]
\label{chase-proofs-tree-width}
  Let $\Sigma$ be a set of \emph{single-headed} GTGDs, $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ a tree-like chase proof over $\Sigma$ from $\mathcal{D}$ and $r \in T_1$ the root node. Let $K$ be the maximum arity of predicates that appear in $\mathcal{D} \cup \Sigma$. Then for every $1 \leq i < n$ and every non-root vertex $v$ of $T_i$, $\mu_i(v)$ is $(K, \Sigma)$-small. In particular, if $\mathcal{D}$ is $(K, \Sigma)$-small, all bags in $(T_i, \mu_i)$ are $(K, \Sigma)$-small.
  \begin{proof}
    By induction on $i$. We look at the rule used to derive $(T_{i+1}, \mu_{i+1})$ from $(T_{i}, \mu_{i})$ and examine the bag at the modified node.
    \begin{itemize}
      \item If the last step was a chase step with a full rule or a propagation step, no term set has been modified for any bag in the chase tree.
      \item If the last step was a chase step from a vertex $v \in T_i$ with an existential rule $\forall \vec{x}. \beta \rightarrow \exists \vec{y}. H$ and a substitution $\sigma$, we have added a new node $c$ under $v$. As $|\Terms(\sigma'(H))| \leq K$ and the inherited bag $I$ has $\Terms(I) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma)$,
      \begin{equation*}
        \begin{split}
          |\Terms(\mu_{i+1}(c)) \setminus \Consts(\Sigma)|
            &= |\Terms(\{\sigma'(H)\} \cup I) \setminus \Consts(\Sigma)| \\
            &\leq K.
        \end{split}
      \end{equation*}
    \end{itemize}
    When $\mathcal{D}$ is $(K, \Sigma)$-small, the result extends to the root node since no chase transformation modifies the term set of the root node.
  \end{proof}
\end{proposition}

At the same time, tree-like chase proofs prove everything we can reason about the input database $\mathcal{D}$, as long as conjunctive queries are concerned.

\begin{proposition}
\label{chase-proof-completeness}
  For any set $\Sigma$ of single-headed GTGDs, a base instance $\mathcal{D}$ and a Boolean conjunctive query $Q$, there exists a tree-like chase proof $C_1, \ldots, C_n$ over $\Sigma$ from $\mathcal{D}$ such that $C_n \models Q$ if and only if $\mathcal{D}, \Sigma \models Q$.
  \begin{proof}[Proof (sketch)] $ $\par
    ($\Longrightarrow$, "soundness" of chase proofs): Suppose that $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ is a tree-like chase proof over $\Sigma$ from $\mathcal{D}$. Take any (Herbrand) structure $\mathcal{M}$ and suppose $\mathcal{M} \models \mathcal{D} \wedge \Sigma$. Write $I_i = \bigcup_{v \in T_i} \mu_i(v)$ for the chased instance at $i$-th step.
    
    By induction on $1 \leq i \leq n$, we can construct an increasing sequence $\sigma_1, \ldots, \sigma_n$ of substitutions such that $\sigma_i$ homomorphically maps all nulls in $I_i$ to $\mathcal{M}$. In particular, $\sigma(I_n) \subseteq \mathcal{M}$, and as $I_n \models Q$, $\mathcal{M} \models Q$.

    ($\Longleftarrow$, "completeness" of chase proofs): This direction is proven in \cite[Proposition 2.6.9]{kappelmann_2019}. The cited proposition shows that an ordinary chase can be decomposed into a tree-like structure, and the decomposition is performed exactly as in the definition of \ref{tree-like-chase-proof}.
  \end{proof}
\end{proposition}

\section{Shortcutting Chase Trees}

Tree-like chase proof is a powerful tool to reason about a fragment of a chase, but unlike a full chase, they do not constitute a model of $\mathcal{D} \cup \Sigma$. Therefore, we wish to construct a model that retains a tree-like structure.

Notice that during a chase proof, we only ever fire an existential rule from a node $n$ in the hope of either
\begin{itemize}
  \item retrieving back a fact to $n$ to accumulate as much facts as possible to $n$, or
  \item finding an existential witness to the query variable in the subtree of $n$.
\end{itemize}
We can immediately achieve the former objective by computing the Datalog saturation of the bag at $n$ using $\ASatRules{\Sigma}$. This observation motivates the following definition.

\begin{definition}[Shortcutting Chase Trees]
  Let $\Sigma$ be a finite set of single-headed GTGDs and $\mathcal{D}$ an instance. We inductively define an infinite sequence $(T_0, \mu_0), (T_1, \mu_1), \ldots$ of chase trees as follows:
  \begin{itemize}
    \item $(T_0, \mu_0)$ is a chase tree with only the root vertex $r$ together with $$\mu_0(r) = \textsc{DatalogSaturate}(\ASatRules{\Sigma}, \mathcal{D}).$$
    \item For the inductive step, $(T_{i + 1}, \mu_{i + 1})$ is constructed by shortcut-chasing all leaves in the previous chase tree $(T_i, \mu_i)$.
    
    More precisely, let $L_i$ be the set of leaf nodes in $T_i$. For each $l \in L_i$, an existential rule $\tau = \forall \vec{x}. \beta \rightarrow \exists \vec{y}. H$ and a substitution $\sigma$ mapping $\vec{x}$ into $\Terms(\mu_i(l))$ such that $\sigma(\beta) \subseteq \mu_i(l)$, define
    \begin{itemize}
      \item $\sigma'$ as an extension of $\sigma$ that maps all variables in $\vec{y}$ to fresh nulls
      \item the bag $B_{l, \tau, \sigma}$ of facts \emph{inherited from $\mu_i(l)$ through $\tau$ and $\sigma$} as $$I_{l, \tau, \sigma} = \{ F \in \mu_i(l) \mid \Terms(f) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma) \}$$
    \end{itemize}
    We construct $T_{i+1}$ as an extension of $T_i$ by adding a vertex $c_{l, \tau, \sigma}$ as a child of $l$ for each such $l \in L_i$, $\tau$ and $\sigma$. We extend $\mu_i$ to $\mu_{i+1}$ by setting $$\mu_{i+1}(c_{l, \tau, \sigma}) = \textsc{DatalogSaturate}(\ASatRules{\Sigma}, \{ \sigma'(H) \} \cup I_{l, \tau, \sigma}).$$
  \end{itemize}
  Finally, the \emph{shortcutting chase tree $\SCTree{\mathcal{D}}{\Sigma}$ of $\mathcal{D}$ over $\Sigma$} is a chase tree defined as the limit $(\bigcup_{i = 0}^\infty T_i, \bigcup_{i = 0}^\infty \mu_i)$ of the sequence defined above.
  \qed
\end{definition}

% TODO: Add a concrete example here. I suppose an infinite shortcutting chase tree and a small conjunctive query serve a good purpose.

The structure of a shortcutting chase tree is very similar to that of a chase proof.

\begin{proposition}
  Let $\Sigma$ be a set of single-headed GTGDs and $\mathcal{D}$ an instance. Let $K$ be the maximum arity of predicates that appear in $\mathcal{D} \cup \Sigma$. Then every bag of facts at a non-root node of \emph{$\SCTree{\mathcal{D}}{\Sigma}$} is $(K, \Sigma)$-small. In particular, if $\mathcal{D}$ is $(K, \Sigma)$-small, all bags in $\SCTree{\mathcal{D}}{\Sigma}$ are $(K, \Sigma)$-small.
  \begin{proof}
    By the same analysis as in the proof of \ref{chase-proofs-tree-width}.
  \end{proof}
\end{proposition}

Expectedly, $\SCTree{\mathcal{D}}{\Sigma}$ is a universal model for $\mathcal{D} \cup \Sigma$.

\begin{theorem}
  For a set $\Sigma$ of single-headed GTGDs, a base instance $\mathcal{D}$ and a Boolean conjunctive query, $\mathcal{D}, \Sigma \models Q$ if and only if $\SCTree{\mathcal{D}}{\Sigma} \models Q$.
  \begin{proof}[Proof (sketch)] $ $\par
    ($\Longrightarrow$): Suppose $\mathcal{D}, \Sigma \models Q$. By \ref{chase-proof-completeness}, there exists a tree-like chase proof $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ from $\mathcal{D}$ over $\Sigma$. By induction on $1 \leq i \leq n$ and by the construction of $\SCTree{\mathcal{D}}{\Sigma}$, we can embed each $(T_i, \mu_i)$ into $\SCTree{\mathcal{D}}{\Sigma}$. Since $(T_n, \mu_n) \models Q$ and $(T_n, \mu_n)$ embeds into $\SCTree{\mathcal{D}}{\Sigma}$, $\SCTree{\mathcal{D}}{\Sigma} \models Q$.

    ($\Longleftarrow$): (TODO: We may choose to embed SCTree into either the oblivious chase sequence (in which case we pick an appropriate finite initial subtree of SCTree) or chase proof).
  \end{proof}
\end{theorem}

\section{Query Homomorphisms into Shortcutting Chase Trees}

We conclude the chapter with an analysis of how a homomorphism from a given conjunctive query to a shortcutting chase tree is structured.

% TODO: Discuss the head-tentacle decomposition of a query homomorphism, and show how the guarded set inherited into the tentacle is the only thing that matters to satisfy the connected subquery existentially (after a specific set of variables are mapped to base constants).

\newpage
\chapter{Deriving a Decision Procedure}

\subsection{Expressing Local Structure of a Shortcutting Chase Tree}

\newpage
\chapter{Implementation, Testing and Evaluation}

\newpage
\chapter{Conclusion}

\printbibliography

\end{document}
