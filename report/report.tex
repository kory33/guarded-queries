\documentclass[12pt]{report}

\usepackage[a4paper, margin=1.3in]{geometry}
\usepackage[maxnames=10]{biblatex}
\usepackage{setspace}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}

\usepackage[dvipsnames]{xcolor}
\hypersetup{
  colorlinks=true,
  linktoc=section,
  linkcolor=RoyalBlue,
  citecolor=RoyalBlue,
  urlcolor=RoyalBlue,
  linkbordercolor=white,
}

% Tell Cref how to reference an algorithm
\crefname{algorithm}{Algorithm}{Algorithms}
\Crefname{algorithm}{Algorithm}{Algorithms}

% settings for amsthm package
% apply chapter-wise theorem numbering for theorems
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

% The following are the numbered elements with "definition style" (i.e. non-italic)
\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}

% Load `.bib` file
\addbibresource{references.bib}

% Symbol definitions
\def\Vars{{\mathrm{Vars}}}
\def\Consts{{\mathrm{Consts}}}
\def\Terms{{\mathrm{Terms}}}
\newcommand{\dom}[1]{\ensuremath{\normalfont{\operatorname{dom}} \left( #1 \right)}}
\newcommand{\ASatRules}[1]{\ensuremath{\normalfont{\textsc{ASatRules}} \left( #1 \right)}}
\newcommand{\BaseVars}[1]{\ensuremath{\normalfont{\textrm{BaseVars}} \left( #1 \right)}}
\newcommand{\NullVars}[1]{\ensuremath{\normalfont{\textrm{NullVars}} \left( #1 \right)}}
\newcommand{\SCTree}[2]{\ensuremath{\normalfont{\textrm{SCTree}} \left( #1, #2 \right)}}
\newcommand{\Subq}[3]{\ensuremath{\normalfont{\textrm{Subq}} \left( #1, #2, #3 \right)}}
\newcommand{\Baseq}[2]{\ensuremath{\normalfont{\textrm{Baseq}} \left( #1, #2 \right)}}

\title{A Step Towards Practical Query Answering Under GTGDs}
\author{Ryosuke Kondo}
\date{May 2023}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

\section*{Abstract}

\newpage
\chapter{Introduction}

\section{Background}

Consider the following situation: (TODO; Think about some OMQA instance where two independent parties provide a data over which we would like to perform an existential join query.)

We would now like to find out (TODO; insert here the query content in English). This amounts to finding all \emph{answers} to a first-order existential sentence (TODO; insert here the query in first-order language), where each answer is a \emph{substitution} mapping free variables (TODO) to constants in data sources that make the sentence true.

Unlike querying a single relational database, it is not sufficient to perform a non-existential join query (TODO; insert here the query with existentials stripped away) and project the resulting tuples to ignore uninteresting components. Even though no constant in the input database matches variables in the partially-applied query (TODO; insert here a partially-applied query), we can deduce from the constraints that there must be some \emph{unknown} values that matches (TODO; insert here a partially-applied query).

In general, the problem of answering queries given (1) a collection of \emph{incomplete} data sources, (2) a finite set of \emph{data integration rules} that can derive the existence of new tuples and (3) a conjunctive query (CQ) is called Ontology-Mediated Query Answering (OMQA) \cite{bienvenu16}.

Data integration rules in OMQA problem instances are often written as Tuple-Generating Dependencies (TGDs), which are first-order sentences of the form $\forall \vec{x}.\ \Phi(\vec{x}, \vec{c}) \rightarrow \exists \vec{y}.\ \Psi(\vec{x}, \vec{y}, \vec{c}')$. In the example above, for instance, the rules can be translated into logical formulae (TODO: translate the rules into TGDs). Formulated this way, we can think of OMQA problems as finding all assignments $\sigma$ of free variables in the input query that validate the logical entailment relation $\mathcal{D} \cup \Sigma \models \sigma(Q)$, where $\mathcal{D}$ is the conjunction of all records present in data sources, $\Sigma$ is the data integration rules and $Q$ is the input CQ.

Unfortunately, however, OMQA problems with general TGDs turned out to be undecidable \cite{beeri_vardi_1981}. In response to this, \cite{cali_gottlob_kifer_2013} identified \emph{Guarded TGDs} (GTGDs) as a subclass of TGDs that leaves OMQA problems decidable, yet expressive enough to contain several classes of description logics.

\section{Previous Works}

Despite OMQA problems over GTGDs being known to be decidable for several years, only a small number of work have been done to develop computationally tractable algorithms for these problems. A recent work \cite{kappelmann_2019} suggested that we can efficiently rewrite a set of GTGD rules into a so-called \emph{Datalog saturation} of it, which is a set of existential-free TGDs that is "equivalent" to the original rule set for existential-free queries. The rewriting algorithm has been improved, implemented and evaluated in \cite{benedikt_buron_germano_kappelmann_motik_2022}. 

(TODO: include a diagram indicating the scheme of how Datalog saturation is incorporated into OMQA)

Even though the implementation by \cite{benedikt_buron_germano_kappelmann_motik_2022} only supports atomic queries out-of-the-box, we can reduce any \emph{acyclic} existential queries into a few guarded rules and a single goal atom containing just the free variables in the original query. For the (TODO: reference to the example given at the beginning of Section 1.1) query, we can add a (TODO)-ary goal predicate $\mathrm{Goal}(-, -)$ and rules (TODO: apply the reduction). However, such reduction does not apply to cyclic queries (e.g. a \emph{triangle query} $\exists x,y,z.\ R(w, x, y) \land S(y, z) \land S(z, x)$) in general.

(TODO: The following two paragraphs clearly do not fit here, but I think they should be present in the introduction, or else the exact problem I worked on is very difficult to communicate. Reorganize?)

It has been known that the entailment $\mathcal{D} \cup \Sigma \models \sigma(Q)$ holds if and only if $\sigma(Q)$ is witnessed by the \emph{chase} of $\mathcal{D}$, which, informally speaking, is the result of \emph{repairing} $\mathcal{D}$ by generating tuples using rules in $\Sigma$ infinitely many times. % citation needed

Moreover, it has also been known that there exists a \emph{Datalog rewriting} of a finite set of GTGD rules and an arbitrary CQ \cite{barany_benedikt_cate_2013}. We will refer the problem of finding a Datalog rewriting of a GTGD rule set and a CQ by \emph{GTGD-Datalog Rewriting}. Note that Datalog-saturating a GTGD rule set is a special case of GTGD-Datalog Rewriting problem where the query is always atomic.

\emph{To the best of my knowledge, however, no work has implemented a query answering procedure for general CQs under GTGDs}. Given that many real-world database queries are cyclic (TODO: evidence?), limiting ourselves to acyclic existential queries may pose issues on smooth adoptation of OMQA systems.

\section{Contribution of This Work}

The contribution of this work is threefold:

\begin{itemize}
  \item By examining the structure of chases, I derived a novel reduction of GTGD-Datalog Rewriting problem into exponentially many small instances of GTGD query answering problems with \emph{Boolean} CQs (BCQs), which no longer have free variables.
  \item By making use of properties of chases, I demonstrate how BCQ answering over GTGD rules can be decided using a simple product of two \emph{tree automata}. By eliminating redundant nondeterminism in these automata, I derived a novel recursive procedure for deciding BCQ entailment problems, which can be memoized to further speed up subsequent BCQ answerings.
  \item Last but not least, I provide a Java implementation of the former two algorithms which, when combined, can be assembled into an OMQA system.
\end{itemize}

\section{Outline of This Report}

(TODO: use in-doc links)

In Chapter 2, I introduce basic terminologies and results that will be used throughout the report.

In Chapter 3, I revisit the notion of "tree-like chase proof" and introduce the notion of "shortcut chases" (TODO: I'm pretty sure this have been defined elsewhere; find a literature if possible and cite here?) with a few diagrams. I then provide a simple analysis of how answers of the input query must be embedded into the chase tree, and argue that for rewriting purpose it is sufficient to decide whether a given rule plus a guarded set is "large enough" to entail a Boolean conjunctive subquery of a particular form.

In Chapter 4, I begin with introducing nondeterministic finitely-branching-tree automata. We then discuss the most natural way to decide BCQ entailment using a formal product of "wildly nondeterministic branching query automaton" and "naive chase automaton". I show that, by carefully balancing the role of these two automata, we can make the chase automaton deterministic, and argue that we can translate the so-obtained automaton into a recursive decision algorithm.

In Chapter 5, we discuss the details of implementation and its verification. I provide some benchmarks to observe how the algorithm runtime increases as the input becomes larger.

We conclude the report with an overview, and discuss some weakness of the algorithm which may be improved in future studies.

\newpage
\chapter{Preliminaries}

% TODO: define formula formalism
% TODO: define TGDs, Datalog rules, full TGDs, guarded TGDs
% TODO: define "instances", and make it clear that we may use a word "bag" in contexts where we don't talk about the whole database
% TODO: define "homomorphism" as an arrow between two sets of facts mapping nulls and variables in the domain set to terms in the target set, such that facts are preserved, and note that this is a rather unconventional typing
% TOOD: define "the subtree T \downarrow v of T as the tree induced by all descendants of v in T"

\section{Datalog Saturation}

Consider the following problem:

\begin{problem}
   Given an existential free conjunctive query $Q$, an input database $\mathcal{D}$ and a Datalog program $P$, find all substitutions (each of which is an \emph{answer} to the query) $\alpha: FV(Q) \rightarrow \Consts(\mathcal{D})$ such that $\mathcal{D} \cup P \models \alpha(Q)$.
\end{problem}

Several algorithms for this problem are known, and \cite{bancilhon_ramakrishnan_1986} compared a few classic algorithms. One of the simplest is the \emph{Naive Evaluation} (\Cref{naive-evaluation-algorithm}). Roughly speaking, we keep adding tuples produced by rules in $P$ to the input database until we reach a fix-point. We then evaluate $Q$, which is merely a join query, on the populated database to obtain all answers.

\begin{algorithm}
\caption{Answering Datalog query using Naive Evaluation}
\label{naive-evaluation-algorithm}
\begin{algorithmic}[1]
\Procedure{DatalogSaturate}{Datalog program $P$, input database $\mathcal{D}$}
  \State $\mathcal{D}_\mathrm{current} \gets \mathcal{D}$
  \While{true}
    \State $\mathcal{D}_\mathrm{next} \gets \mathcal{D}_\mathrm{current}$
    \ForAll{$r \in P$}
      \ForAll{$\sigma \in $ result of matching the body of $r$ on $\mathcal{D}_\mathrm{current}$}
        \State add all head atoms of $r$ substituted with $\sigma$ to $\mathcal{D}_\mathrm{next}$
      \EndFor
    \EndFor
    \State
    \If{$\mathcal{D}_\mathrm{next} \neq \mathcal{D}_\mathrm{current}$}
      \State $\mathcal{D}_\mathrm{next} \gets \mathcal{D}_\mathrm{current}$
    \Else
      \State \Return{$\mathcal{D}_\mathrm{current}$}
    \EndIf
  \EndWhile
\EndProcedure
\State
\Procedure{AnswerDatalogQuery}{$P$, $\mathcal{D}$, $\exists$-free query $Q$}
  \State \Return{result of running the join query $Q$ on $\textsc{DatalogSaturate}(P, \mathcal{D})$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

We call the database instance $\textsc{DatalogSaturate}(P, \mathcal{D})$ the \emph{Datalog saturation of $\mathcal{D}$ with $P$}. Intuitively, a Datalog saturation results from \emph{supplementing} the input instance by adding all but nothing other than facts derivable from the original instance.

\section{Problem Formulation}

% Define output of GSat as "atomic saturation" of a GTGD set
Our ultimate goal is to answer the following problem.

\begin{problem}[GTGD-CQ Answering]
\label{GTGD-CQ-Answering}
  Given a finite set $\Sigma$ of GTGDs, a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j(\vec{u})$ and a base instance $\mathcal{D}$, what are the \emph{answers} to $Q$ under $\Sigma$ and $\mathcal{D}$, i.e. substitutions $\alpha: FV(Q) \rightarrow \Consts(\mathcal{D})$ such that $\mathcal{D} \cup \Sigma \models \alpha(Q)$?
\end{problem}

% Motivate why we want to compute Datalog rewritings by talking about data complexity, cite the result showing the existence and finally formally define.

It is known that a conjunctive query under GTGDs admits \emph{Datalog rewritings} \cite{barany_benedikt_cate_2013}. These are Datalog programs with a designated \emph{goal atom} that, when run on any base instance, give the same set of answers as the original rule-query pair. More precisely:

\begin{definition}
  A \emph{Datalog rewriting} of a GTGD-CQ pair $(\Sigma, Q)$ is a Datalog program $\Sigma_\mathrm{Datalog}$ together with an atomic query $Q_\mathrm{atomic}$ such that for every base instance $\mathcal{D}$ and a substitution $\alpha: FV(Q) \rightarrow \Consts(\mathcal{D})$ for $Q$, $$\Sigma, \mathcal{D} \models \alpha(Q) \textit{ if and only if } \Sigma_\mathrm{Datalog}, \mathcal{D} \models \alpha(Q_\mathrm{atomic}).$$
  We call $Q_\mathrm{atomic}$ the \emph{goal atom} in the Datalog rewriting.
\end{definition}

This project aims to derive an algorithm that produces Datalog rewritings for arbitrary GTGD-CQ pairs.

\newpage
\chapter{Characterising Query Entailment under GTGDs}
\label{characterising-query-entailment-under-gtgds}

\section{Tree-Like Chase Proofs}

In the presence of existential rules, an object known as the \emph{chase} represents a canonical \emph{completion} of a database concerning some data integration rules. Chases are constructed similarly to Datalog saturations by adding tuples produced by rules, except we need to replace existential variables with \emph{nulls}, which represent fresh constants \cite{fagin_kolaitis_miller_popa_2005}.

As with Datalog saturations, the chase of an instance $\mathcal{D}$ gives all possible answers $\sigma: \vec{z} \rightarrow \Consts(\mathcal{D})$ to a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$. That is, we can find all answers to $Q$ by evaluating a join query $\bigwedge_{j \in J} A_j$ on the chase and projecting $\vec{z}$ away.

However, in the presence of recursive rules such as $R(x, y) \rightarrow \exists z.\ R(y, z)$, the chase procedure may have to be continued indefinitely, producing an infinite chase. Moreover, as one keeps populating the database instance with tuples regardless of whether they eventually affect query output, the chase lacks a structure with which we can reason about query entailments.

% TODO: which paper introduced tree-like chase proofs for Datalog+-?
To deal with this issue, \cite{benedikt_buron_germano_kappelmann_motik_2022} introduced the notion of \emph{tree-like chase proofs}, which essentially capture instants of ongoing chase processes.

\begin{definition}
  A \emph{chase tree} is a pair of a (potentially infinite) rooted directed tree $T$ together with a function $\mu$ mapping each vertex $v \in T$ to bags of facts (possibly with nulls). We shall often idenfify a chase tree $(T, \mu)$ with the set $\bigcup_{v \in T} \mu(v)$ of facts in it.
\end{definition}

Chase trees can be infinite in general, but we focus on finite chase trees in this section. The following definition incorporates ideas from \cite{benedikt_buron_germano_kappelmann_motik_2022} and \cite{kappelmann_2019}.

\begin{definition}
\label{tree-like-chase-proof}
  Given a set $\Sigma$ of single-headed GTGDs and a base instance $\mathcal{D}$, a \emph{tree-like chase proof over $\Sigma$ from $\mathcal{D}$} is a finite sequence of chase trees $C_1, \ldots, C_n$ such that
  \begin{itemize}
    \item $C_1 = (T, \mu)$ is a chase tree with a single vertex $v$ together with $\mu(v) = \mathcal{D}$.
    \item for each $i < n$, $C_{i + 1}$ is obtained from $C_i = (T, \mu)$ by applying one of the following transformation steps.
    \begin{itemize}
      \item \emph{a chase step} from a vertex $v \in T$ with $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ and a substitution $\sigma$ mapping $\vec{x}$ to constants in $\mu(v)$, provided that $\sigma(\beta) \subseteq \mu(v)$. The result $(T', \mu')$ of this step depends on whether $\tau$ is full, i.e. if $|\vec{y}| = 0$:
      \begin{itemize}
        \item If $\tau$ is full, we simply add the head atom $H$ of $\tau$ to the instance at $v$. That is, we keep $T' = T$, and set $\mu'(v) = \mu(v) \cup \sigma(H)$ while maintaining $\mu$ and $\mu'$ equal on $T \setminus \{v\}$.
        \item If $\tau$ is existential, we create a fresh child of $v$, put produced fact in it and \emph{inherit} facts from the parent instance. To do so, we first extend $\sigma$ to a substitution $\sigma'$ that maps variables in $\vec{y}$ to fresh nulls. We define the instance $I$ containing \emph{inherited facts} as $$I = \{ F \in \mu(v) \mid \Terms(f) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma) \}.$$ Finally, we prepare a fresh vertex $c$, form $T'$ by making $c$ a child of $v$, and extend $\mu$ to $\mu'$ with $\mu'(c) = \{\sigma'(H)\} \cup I$.
      \end{itemize}
      \item \emph{a propagation step} from a vertex $v \in T$ to an ancestor $a \in T$ of $v$ with a fact $f \in \mu(v)$, provided that $f \not\in \mu(a)$ and $\Terms(f) \subseteq \Terms(\mu(a)) \cup \Consts(\Sigma)$. The resulting chase tree is $(T, \mu')$, where $\mu'$ agrees with $\mu$ everywhere except at $a$, and $\mu'(a) = \mu(a) \cup \{f\}$.
    \end{itemize}
  \end{itemize}
\end{definition}

A tree-like chase proof over $\Sigma$ from $\mathcal{D}$ represents a process of supplementing $\mathcal{D}$ according to $\Sigma$. We can derive new tuples by using a chase step, branching off to a child node when introducing nulls corresponding to existential values. With a propagation step, we can retrieve a fact derived at a descendant node to the ancestor node.

Note that we only propagate or inherit facts whose terms appear in the target node. Intuitively, such a restriction can be justified because the guardedness of rules in $\Sigma$ prohibits us from \emph{combining} unrelated terms into new tuples. We cannot hope to fire an existential rule from a node $a \in T$ in a meaningfully novel manner even if we transfer to $a$ a fact with terms not already present in $a$. That is, if we propagated a fact $F$ from $v$ to $a$ and could fire a rule $(\tau, \sigma)$ on $a$ \emph{using} $F$, we could have fired $(\tau, \sigma)$ on $v$ in the first place, provided that $v$ inherited enough facts related to $F$ from $a$\footnote{In fact, $a$ might have more facts with terms in $F$ than $v$ does due to propagation from cousin nodes of $v$. In that case, we could "re-derive" a cousin node $v'$ from $a$ in the same way as how $v$ had been derived, and $v'$ should have as many facts related to an isomorphic copy of $F$ as $a$ does.}.

% NOTE: It may be better to call this quantity "width", but it is slightly different from treewidth since we exclude rule constants. I could not come up with a fitting word here.

The restriction mentioned above makes the local structure of tree-like chase proofs \emph{small} in the following sense.

\begin{definition}
  Let $\Sigma$ be a set of GTGDs and $K \in \mathbb{N}$. We say that a bag $\mathcal{B}$ of facts is \emph{$(K, \Sigma)$-small} when $|\Terms(\mathcal{B}) \setminus \Consts(\Sigma)| \leq K$.
\end{definition}

\begin{proposition}[Tree-width of chase proofs]
\label{chase-proofs-tree-width}
  Let $\Sigma$ be a set of \emph{single-headed} GTGDs, $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ a tree-like chase proof over $\Sigma$ from $\mathcal{D}$. Let $K$ be the maximum arity of predicates that appear in $\mathcal{D} \cup \Sigma$. Then for every $1 \leq i < n$ and every non-root vertex $v$ of $T_i$, $\mu_i(v)$ is $(K, \Sigma)$-small. In particular, if $\mathcal{D}$ is $(K, \Sigma)$-small, all bags in $(T_i, \mu_i)$ are $(K, \Sigma)$-small.
  \begin{proof}
    By induction on $i$. The base case $i = 1$ is vacuous. We look at the rule used to derive $(T_{i+1}, \mu_{i+1})$ from $(T_{i}, \mu_{i})$ and examine the bag at the modified node.
    \begin{itemize}
      \item If the last step was a chase step with a full rule or a propagation step, no term set has been modified for any bag in the chase tree.
      \item If the last step was a chase step from a vertex $v \in T_i$ with an existential rule $\forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ and a substitution $\sigma$, we have added a new node $c$ under $v$. As $|\Terms(\sigma'(H))| \leq K$ and the inherited bag $I$ has $\Terms(I) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma)$,
      \begin{equation*}
        \begin{split}
          |\Terms(\mu_{i+1}(c)) \setminus \Consts(\Sigma)|
            &= |\Terms(\{\sigma'(H)\} \cup I) \setminus \Consts(\Sigma)| \\
            &\leq K.
        \end{split}
      \end{equation*}
    \end{itemize}
    When $\mathcal{D}$ is $(K, \Sigma)$-small, the result extends to the root node since no chase transformation modifies the term set of the root node.
  \end{proof}
\end{proposition}

At the same time, tree-like chase proofs prove everything we can reason about the input database $\mathcal{D}$, as long as conjunctive queries are concerned.

\begin{proposition}
\label{chase-proof-completeness}
  For any set $\Sigma$ of single-headed GTGDs, a base instance $\mathcal{D}$ and a Boolean conjunctive query $Q$, there exists a tree-like chase proof $\ C_1, \ldots, C_n$ over $\Sigma$ from $\mathcal{D}$ such that $C_n \models Q$ if and only if $\mathcal{D} \cup \Sigma \models Q$.
  \begin{proof}[Proof (sketch)] $ $\par
    ($\Longrightarrow$, "soundness" of chase proofs): Suppose that $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ is a tree-like chase proof over $\Sigma$ from $\mathcal{D}$. For each $1 \leq i \leq n$, let $I_i = \bigcup_{v \in T_n} \mu_n(v)$ be the instance containing all facts in $(T_i, \mu_i)$. The sequence $I_1, \ldots, I_n$ is known as a \emph{chase sequence}, and \cite{fagin_kolaitis_miller_popa_2005} showed that $Q$ follows from $\mathcal{D}$ if there is a chase sequence ending with $I_n \models Q$.

    ($\Longleftarrow$, "completeness" of chase proofs): This direction is proven in \cite[Proposition 2.6.9]{kappelmann_2019}. The proof therein decomposes an ordinary chase sequence into a tree-like structure, and the decomposition is performed exactly as in \Cref{tree-like-chase-proof}.
  \end{proof}
\end{proposition}

\section{Shortcutting Chase Trees}

Tree-like chase proof is a powerful tool to reason about a fragment of a chase, but unlike a full chase, they do not constitute a model of $\mathcal{D} \cup \Sigma$. Therefore, we wish to construct a model that retains a tree-like structure.

Notice that during a chase proof, we only ever fire an existential rule from a node $n$ in the hope of either
\begin{itemize}
  \item retrieving back a fact to $n$ to accumulate as much facts as possible to $n$, or
  \item finding an existential witness to the query variable in the subtree of $n$.
\end{itemize}
We can immediately achieve the former objective by computing the Datalog saturation of the bag at $n$ using $\ASatRules{\Sigma}$. This observation motivates the following definition.

\begin{definition}[Shortcutting Chase Trees]
  Let $\Sigma$ be a finite set of single-headed GTGDs and $\mathcal{D}$ an instance. We inductively define an infinite sequence $(T_0, \mu_0), (T_1, \mu_1), \ldots$ of chase trees as follows:
  \begin{itemize}
    \item $(T_0, \mu_0)$ is a chase tree with only the root vertex $r$ together with $$\mu_0(r) = \textsc{DatalogSaturate}(\ASatRules{\Sigma}, \mathcal{D}).$$
    \item For the inductive step, $(T_{i + 1}, \mu_{i + 1})$ is constructed by shortcut-chasing all leaves in the previous chase tree $(T_i, \mu_i)$.
    
    More precisely, let $L_i$ be the set of leaf nodes in $T_i$. For each $l \in L_i$, an existential rule $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ and a substitution $\sigma$ mapping $\vec{x}$ into $\Terms(\mu_i(l))$ such that $\sigma(\beta) \subseteq \mu_i(l)$, define
    \begin{itemize}
      \item $\sigma'$ as an extension of $\sigma$ that maps all variables in $\vec{y}$ to fresh nulls
      \item the bag $B_{l, \tau, \sigma}$ of facts \emph{inherited from $\mu_i(l)$ through $\tau$ and $\sigma$} as $$I_{l, \tau, \sigma} = \{ F \in \mu_i(l) \mid \Terms(f) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma) \}$$
    \end{itemize}
    We construct $T_{i+1}$ as an extension of $T_i$ by adding a vertex $c_{l, \tau, \sigma}$ as a child of $l$ for each such $l \in L_i$, $\tau$ and $\sigma$. We extend $\mu_i$ to $\mu_{i+1}$ by setting $$\mu_{i+1}(c_{l, \tau, \sigma}) = \textsc{DatalogSaturate}(\ASatRules{\Sigma}, \{ \sigma'(H) \} \cup I_{l, \tau, \sigma}).$$
  \end{itemize}
  Finally, the \emph{shortcutting chase tree $\SCTree{\mathcal{D}}{\Sigma}$ of $\mathcal{D}$ over $\Sigma$} is a chase tree defined as the limit $(\bigcup_{i = 0}^\infty T_i, \bigcup_{i = 0}^\infty \mu_i)$ of the sequence defined above.
  \qed
\end{definition}

% TODO: Add a concrete example here. I suppose an infinite shortcutting chase tree and a small conjunctive query serve a good purpose.

The structure of a shortcutting chase tree is very similar to that of a chase proof.

\begin{proposition}
  Let $\Sigma$ be a set of single-headed GTGDs and $\mathcal{D}$ an instance. Let $K$ be the maximum arity of predicates that appear in $\mathcal{D} \cup \Sigma$. Then every bag of facts at a non-root node of \emph{$\SCTree{\mathcal{D}}{\Sigma}$} is $(K, \Sigma)$-small. In particular, if $\mathcal{D}$ is $(K, \Sigma)$-small, all bags in $\SCTree{\mathcal{D}}{\Sigma}$ are $(K, \Sigma)$-small.
  \begin{proof}
    By the same analysis as in the proof of \Cref{chase-proofs-tree-width}.
  \end{proof}
\end{proposition}

Expectedly, $\SCTree{\mathcal{D}}{\Sigma}$ is a universal model for $\mathcal{D} \cup \Sigma$, since any finite subtree of $\SCTree{\mathcal{D}}{\Sigma}$ homomorphically embeds into some chase proof.

\begin{lemma}
\label{sctree-subtree-embeds-into-a-chase-proof}
  Let $\mathcal{D}$ be a base instance and $\Sigma$ a finite set of single-headed GTGDs. Then for any finite rooted subtree $(T, \mu)$ of $\SCTree{\mathcal{D}}{\Sigma}$, there exists a tree-like chase proof $C_1, \ldots, C_n$ that admits a homomorphism $\sigma: (T, \mu) \rightarrow C_n$.
  \begin{proof}
    By induction on the structure of $(T, \mu)$.

    The base case is $T = \{r\}$, where $r$ is the root of $\SCTree{\mathcal{D}}{\Sigma}$. By \Cref{chase-proof-completeness}, we can construct a chase-proof $C_1, \ldots, C_n$ that aggregates all provable base facts to the root bag.

    For the inductive part, take a finite rooted subtree $(T, \mu)$ and a leaf $l$ of $T$, and suppose that $T \setminus \{l\}$ can be homomorphically mapped into the last chase tree in a proof $C_1, \ldots, C_n$. Let $(\tau, \sigma)$ be a pair of a rule and a substitution used to derive $l$.
    
    We extend the proof $C_1, \ldots, C_n$ by applying a chase step with $(\tau, \sigma)$ to create a child node $c \in C_{n+1}$. By \Cref{chase-proof-completeness}, we can derive all facts whose terms appear in the bag $c$. We have now obtained a chase proof $C_1, \ldots, C_{n+m}$ with $c$ saturated, so $(T, \mu)$ can be homomorphically mapped into $C_{n+m}$.
  \end{proof}
\end{lemma}

\begin{theorem}
\label{sctree-soundness-completeness}
  For a set $\Sigma$ of single-headed GTGDs, a base instance $\mathcal{D}$ and a Boolean conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$, $\mathcal{D} \cup \Sigma \models Q$ if and only if $\SCTree{\mathcal{D}}{\Sigma} \models Q$.
  \begin{proof}[Proof] $ $\par
    ($\Longrightarrow$): Suppose $\mathcal{D} \cup \Sigma \models Q$. By \Cref{chase-proof-completeness}, there exists a tree-like chase proof $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ from $\mathcal{D}$ over $\Sigma$. By induction on $1 \leq i \leq n$ and by the construction of $\SCTree{\mathcal{D}}{\Sigma}$, we can embed each $(T_i, \mu_i)$ into $\SCTree{\mathcal{D}}{\Sigma}$. Since $(T_n, \mu_n) \models Q$ and $(T_n, \mu_n)$ embeds into $\SCTree{\mathcal{D}}{\Sigma}$, $\SCTree{\mathcal{D}}{\Sigma} \models Q$.

    ($\Longleftarrow$): Suppose $\SCTree{\mathcal{D}}{\Sigma} \models Q$. Then there exists a homomorphism $\sigma:\nobreak Q \rightarrow \Terms(\SCTree{\mathcal{D}}{\Sigma})$.
    
    We may pick a finite rooted subtree $(T, \mu)$ of $\SCTree{\mathcal{D}}{\Sigma}$ such that $\sigma$ restricts to $\sigma: Q \rightarrow (T, \mu)$. To do so, for each $j \in J$, let $N_j \in \SCTree{\mathcal{D}}{\Sigma}$ be a set of nodes whose bags contain the fact $\sigma(A_j)$. Choose $n_j \in N_j$ for each $j \in J$, and let $T_j$ be the set of all ancestors of $n_j$. Finally, let $T = \bigcup_{j \in J} T_j$.

    By applying \Cref{sctree-subtree-embeds-into-a-chase-proof} to $(T, \mu)$, there is a chase proof of $Q$ from $\mathcal{D}$ under $\Sigma$. By soundness of chase proofs (\Cref{chase-proof-completeness}, $\Longrightarrow$) we are done.
  \end{proof}
\end{theorem}

\begin{remark}
\label{coinductiveness-of-sctree}
  A shortcutting tree chase has a \emph{coinductive} structure: If we write $\mu$ for the bag assignment function of $\SCTree{\mathcal{D}}{\Sigma}$, then for any vertex $v \in \SCTree{\mathcal{D}}{\Sigma}$, the subtree $\SCTree{\mathcal{D}}{\Sigma} \downarrow v$ of all descendants (including $v$ itself) of $v$ can be written as $\SCTree{\mathcal{D}}{\Sigma} \downarrow v = \SCTree{\mu(v)}{\Sigma}$.
\end{remark}

% TODO: a diagram illustrating how a subtree is another shortcut chase tree should be inserted here

\section{Query Satisfaction in Shortcutting Chase Trees}

We now discuss how the structure of the query constrains the structure of query homomorphisms into the shortcutting chase tree. By the end of this chapter, we will have derived a recursive query answering procedure, whose recursive structure will be exploited in \Cref{deriving-a-rewriting} to compute a Datalog rewriting.

A key observation is that a \emph{connected} set of variables produces a connected homomorphic image in $\SCTree{\mathcal{D}}{\Sigma}$. To make this intuition precise, we introduce the following terminology.

\begin{definition}
  Given a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$, we say that
  \begin{itemize}
    \item two variables $z_1, z_2$ bound in $Q$ are \emph{$Q$-adjacent} if some atom $A_j$ in $Q$ contains both $z_1$ and $z_2$
    \item a set $Z$ of variables bound in $Q$ are \emph{$Q$-connected} if for each pair $z_1, z_2 \in Z$ of variables, there is a finite sequence $x_1, \ldots, x_n$ of variables in $Z$ such that
    \begin{itemize}
      \item $x_1 = z_1$ and $x_n = z_2$
      \item for each $1 \leq i < n$, $x_i$ and $x_{i+1}$ are $Q$-adjacent
    \end{itemize}
  \end{itemize}

  For a subset $Z$ of $\vec{z}$, a \emph{$Q$-connected component of $Z$} is a $\subseteq$-maximal $Q$-connected nonempty subset of $Z$.

  Finally, $Q$ is a \emph{connected} conjunctive query if $\vec{z}$ is $Q$-connected.
  \qed
\end{definition}

A set $Z$ of bound variables is $Q$-connected if the hypergraph corresponding to the structure of $Q$ (with $Z$ as the vertex set and atoms in $Q$ as the hyperedges) is connected, as illustrated in the following example.

\begin{example}
  Consider a conjunctive query $$Q = \exists z_1,z_2,z_3,z_4,z_5.\ S(z_1, z_2) \wedge S(z_1,z_3) \wedge R(z_2,z_3) \wedge R(z_3, z_4) \wedge R(z_3, z_5).$$
  Then $\{z_1, z_3, z_4\}$ and $\{z_2, z_3, z_5\}$ are both $Q$-connected, but $\{z_1, z_2, z_4\}$ and $\{z_4, z_5\}$ are not.

  $Q$-connected components of $\{z_1, z_2, z_4, z_5\}$ are $\{z_1,z_2\}$, $\{z_4\}$ and $\{z_5\}$.
  \qed
  % TODO: a picture helps!
\end{example}

We are ready to state the observation.

\begin{lemma}[\emph{Homomorphic image of connected variables is connected}]
\label{image-of-connected-variables-is-connected}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query, $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ a homomorphism, and $Z$ a nonempty, $Q$-connected subset of $\vec{z}$.

  If we write $T_Z$ for the set of nodes in $\SCTree{\mathcal{D}}{\Sigma}$ whose bags contain a term in $\sigma(Z)$, then $T_Z$ is a rooted subtree of $\SCTree{\mathcal{D}}{\Sigma}$.
  \begin{proof}
    For each term $t \in \sigma(Z)$, let $V_t \subseteq \SCTree{\mathcal{D}}{\Sigma}$ be the set of nodes in which $t$ appears. We wish to see that $T_Z = \bigcup_{t \in \sigma(Z)} V_t$ is a rooted subtree of $\SCTree{\mathcal{D}}{\Sigma}$. Since $T_Z$ is nonempty, it suffices to show the connectedness of $T_Z$.

    So take two vertices $v_1, v_2 \in T_Z$, and let $z_1, z_2 \in Z$ be variables bound in $Q$ such that $v_i \in V_{\sigma(z_i)}$ for $i \in \{1, 2\}$. As $Z$ is $Q$-connected, there exists a sequence $z_1 = x_1, \ldots, x_n = z_2$ of variables in $Z$ such that $x_i$ and $x_{i+1}$ are $Q$-adjacent for each $1 \leq i < n$.

    For each $i$, there exists an atom $A$ containing both $x_i$ and $x_{i+1}$. As \newline $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is a query homomorphism, there exists a node $v$ in $\SCTree{\mathcal{D}}{\Sigma}$ that contains $\sigma(A)$. In particular, $v$ contains both $\sigma(x_i)$ and $\sigma(x_{i+1})$, so $V_\sigma(x_i) \cap V_\sigma(x_{i+1}) \neq \emptyset$.

    By construction of $\SCTree{\mathcal{D}}{\Sigma}$, each $V_\sigma(x_i)$ is connected, so there is a path in $\SCTree{\mathcal{D}}{\Sigma}$ that joins $v_1$ and $v_2$ through intersections $V_\sigma(x_i) \cap V_\sigma(x_{i+1})$.
  \end{proof}
\end{lemma}

We will use \Cref{image-of-connected-variables-is-connected} to develop a query-answering procedure. To begin with, we define a way to split the query entailment checking problem into smaller problems by a partial guess of the query homomorphism.

%TODO: "base part" should be "partially committed part" or something like that, since it is not necessarily at the base.

\begin{definition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query, $\SCTree{\mathcal{D}}{\Sigma}$ a shortcutting chase tree over an instance $\mathcal{D}$ (which may contain nulls) and $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D})$ a partial map from query variables to terms in $\mathcal{D}$. Let $\mathrm{BVars} = \dom{\sigma_\mathrm{partial}}$.

  We define the \emph{base part $\Baseq{Q}{\sigma_\mathrm{partial}}$ of $Q$ according to $\sigma_\mathrm{partial}$} as the variable-free query
  $$\Baseq{Q}{\sigma_\mathrm{partial}} = \bigwedge_{\substack{j \in J \\ \Vars(A_j) \subseteq \mathrm{BVars}}} \sigma_\mathrm{partial}(A_j).$$

  For each $Q$-connected component $C$ of $(\vec{z} \setminus \mathrm{BVars})$, the \emph{subquery $\Subq{Q}{\sigma_\mathrm{partial}}{C}$ of $Q$ induced by $\sigma_\mathrm{partial}$ and $C$} is the connected Boolean conjunctive query defined by
  $$\Subq{Q}{\sigma_\mathrm{partial}}{C} = \exists \vec{C}. \bigwedge_{j \in J'} \sigma_\mathrm{partial}(A_j),$$
  where $$J' = \{ j \in J \mid \Vars(A_j) \subseteq C \cup \mathrm{BVars} \}.$$
  \qed
\end{definition}

Intuitively, the partial map $\sigma_\mathrm{partial}$ represents a partial commitment towards constructing the whole homomorphism. $\Baseq{Q}{\sigma_\mathrm{partial}}$ is a collection of atoms which we expect to see in (Datalog saturation of) the input instance, and for each $C$, $\Subq{Q}{\sigma_\mathrm{partial}}{C}$ is a query whose entailment tells us if $\sigma_\mathrm{partial}$ had been a valid choice.

As the following lemma states, the original query is satisfied precisely when all split queries are.

% TODO: maybe we can get rid of \alpha in this lemma (and leave general CQ case for a corollary)
\begin{lemma}[Base-connected query decomposition]
\label{bcq-base-connected-query-decomposition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a Boolean conjunctive query, $\mathcal{D}$ an instance and $\Sigma$ a finite set of single-headed GTGDs. Then $\mathcal{D} \cup \Sigma \models Q$ if and only if there exists a partial map $\sigma_\mathrm{partial}: \vec{z} \rightharpoonup \Terms(\mathcal{D})$ such that
  \begin{itemize}
    \item $\mathcal{D} \cup \Sigma \models \Baseq{Q}{\sigma_\mathrm{partial}}$
    \item $\mathcal{D} \cup \Sigma \models \Subq{Q}{\sigma_\mathrm{partial}}{C}$ for each $Q$-connected component $C$ of \newline $(\vec{z} \setminus\nobreak \mathrm{\dom{\sigma_\mathrm{partial}}})$.
  \end{itemize}
  \begin{proof}
    ($\Longrightarrow$): Suppose $\mathcal{D} \cup \Sigma \models Q$. Then by \Cref{sctree-soundness-completeness}, there exists a query homomorphism $\sigma: Q \rightarrow \Terms(\SCTree{\mathcal{D}}{\Sigma})$. Let $$B = \{ v \in \vec{z} \mid \sigma(v) \in \Terms(\mathcal{D}) \},$$ then $(\sigma \upharpoonright B)$ is a partial map satisfying conditions in the lemma.

    ($\Longleftarrow$): Suppose that $\sigma_\mathrm{partial}$ satisfies the two conditions, and let $C_1, \ldots, C_n$ be $Q$-connected components of $(\vec{z} \setminus\nobreak \mathrm{\dom{\sigma_\mathrm{partial}}})$. For each $1 \leq i \leq n$, we can take a query homomorphism $\sigma_{C_i}: \Subq{Q}{\sigma_\mathrm{partial}}{C_i} \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ by \Cref{sctree-soundness-completeness}. Since all of $\sigma_\mathrm{partial}, \sigma_{C_1}, \ldots, \sigma_{C_n}$ have disjoint domains, $\sigma = \sigma_\mathrm{partial} \cup \sigma_{C_1} \cup \ldots \cup \sigma_{C_n}$ is a function $\sigma: \vec{z} \rightarrow \Terms(\SCTree{\mathcal{D}}{\Sigma})$.
    
    Since every atom $A_j$ in $Q$ appears either in $\Baseq{Q}{\sigma_\mathrm{partial}}$ or in precisely one $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$, $\sigma$ is a query homomorphism $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$, and therefore $\mathcal{D} \cup \Sigma \models Q$.
  \end{proof}
\end{lemma}

We can easily extend \Cref{bcq-base-connected-query-decomposition} to non-Boolean conjunctive queries.

\begin{corollary}
\label{base-connected-query-decomposition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a Boolean conjunctive query, $\mathcal{D}$ an instance and $\Sigma$ a finite set of single-headed GTGDs.
  
  Then for a substitution $\alpha: FV(Q) \rightarrow \Terms(\mathcal{D})$, $\mathcal{D} \cup \Sigma \models \alpha(Q)$ if and only if there exists an extension $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D})$ of $\alpha$ satisfying conditions as in \Cref{bcq-base-connected-query-decomposition}.
\end{corollary}

% TODO: put a helpful diagram

In order to produce answers to the query using \Cref{base-connected-query-decomposition}, we need to decide whether or not $\mathcal{D} \cup \Sigma \models \Subq{Q}{\sigma_\mathrm{base}}{C}$ holds. It turns out that we can exploit the connectedness of $\Subq{Q}{\sigma_\mathrm{base}}{C}$ and the coinductive structure of $\SCTree{\mathcal{D}}{\Sigma}$ (\Cref{coinductiveness-of-sctree}) to check the query entailment recursively. To make this precise, we define the notion of a \emph{successful branching point}, a point at which a connected Boolean conjunctive query can be split as in \Cref{bcq-base-connected-query-decomposition}.

\begin{definition}
\label{successful-branching-point-definition}
  Let $Q$ be a connected Boolean conjunctive query and $\SCTree{\mathcal{D}}{\Sigma}$ a shortcutting chase tree. We say that a vertex $v \in \SCTree{\mathcal{D}}{\Sigma}$ with the associated set $\mu(v)$ of facts is a \emph{successful branching point for $Q$ in $\SCTree{\mathcal{D}}{\Sigma}$} if there exists a partial map $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mu(v))$, which we call a \emph{branching map at $v$}, such that
  \begin{itemize}
    \item $\dom{\sigma_\mathrm{partial}}$ is nonempty
    \item $\mu(v) \models \Baseq{Q}{\sigma_\mathrm{partial}}$
    \item $\SCTree{\mu(v)}{\Sigma} \models \Subq{Q}{\sigma_\mathrm{partial}}{C}$ for each $Q$-connected component $C$ of $(\Vars(Q) \setminus \dom{\sigma_\mathrm{partial}})$
  \end{itemize}
  \qed
\end{definition}

To witness the entailment of a connected Boolean conjunctive query, finding a \emph{single} such vertex in the shortcutting chase tree suffices.

\begin{theorem}
\label{recursive-connected-bcq-entailment}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a connected Boolean conjunctive query, $\mathcal{D}$ an instance and $\Sigma$ a finite set of single-headed GTGDs. Then $\mathcal{D} \cup \Sigma \models Q$ if and only if there exists a successful branching point for $Q$ in $\SCTree{\mathcal{D}}{\Sigma}$.
  \begin{proof}
    ($\Longrightarrow$): Suppose that $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is a query homomorphism. By \Cref{image-of-connected-variables-is-connected}, the set $T_{\Vars(Q)}$ of nodes in which terms in $\sigma(\Vars(Q))$ appear is a rooted tree in $\SCTree{\mathcal{D}}{\Sigma}$. Let $r$ be the root of $T_{\Vars(Q)}$ and $\mu(r)$ the bag of facts at $r$ in $\SCTree{\mathcal{D}}{\Sigma}$. We aim to show that $r$ is a successful branching point for $Q$.

    By \Cref{coinductiveness-of-sctree}, $T_{\Vars(Q)} = \SCTree{\mu(r)}{\Sigma}$. Since terms in $\sigma(\Vars(Q))$ only appear in $T_{\Vars(Q)}$, $\sigma$ is a query homomorphism $\sigma: Q \rightarrow \SCTree{\mu(r)}{\Sigma}$. Let $B = \{ v \in \Vars(Q) \mid \sigma(v) \in \Terms(r) \}$ be a nonempty set of variables mapped to $r$, and define $Q_B$ to be the query $$Q_B = \exists \overrightarrow{(\Vars(Q) \setminus B)}. \bigwedge_{j \in J}(A_j)$$ with free variables $B$. Then $\mu(r) \cup \Sigma \models (\sigma \upharpoonright B)(Q)$, so apply \Cref{base-connected-query-decomposition} and we have a branching map at $r$.

    ($\Longleftarrow$): Suppose that $v$ is a successful branching point with a branching map $\sigma_\mathrm{partial}$. Let $C_1, \ldots, C_n$ be $Q$-connected components of $(\Vars(Q) \setminus \dom{\sigma_\mathrm{partial}})$. Then for each $1 \leq i \leq n$, we may pick a query homomorphism $\sigma_{C_i}: \Subq{Q}{\sigma_\mathrm{partial}}{C_i} \rightarrow \SCTree{\mu(v)}{\Sigma}$ by \Cref{chase-proof-completeness}. If we let $\sigma = \sigma_\mathrm{partial}, \sigma_{C_1}, \ldots, \sigma_{C_n}$, then we can check that $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is a query homomorphism as in the proof of \Cref{bcq-base-connected-query-decomposition}.
  \end{proof}
\end{theorem}

\begin{remark}
\label{remark-towards-query-answering-procedure}
  Notice that, to decide whether a vertex $v$ in $\SCTree{\mathcal{D}}{\Sigma}$ is a successful branching point for $Q$ with a branching map $\sigma_\mathrm{partial}$, we also need to decide if subqueries $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$ are satisfied in the subtree $\SCTree{\mu(v)}{\Sigma}$. As we require the branching map $\sigma_\mathrm{partial}$ to be a nonempty map, each subquery $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$ is a connected Boolean query strictly smaller than $Q$.

  Moreover, for Boolean conjunctive queries, the query entailment is unaffected by a certain renaming of constants. Therefore, we only need to search for successful branching points up to renaming equivalence.
  \qed
\end{remark}

We capture the latter intuition with the following.

\begin{definition}
  Let $\mathcal{D}$ be an instance. A \emph{$\Sigma$-preserving renaming on $\mathcal{D}$} is an injective function $\sigma: \Terms(\mathcal{D}) \setminus \Consts(\Sigma) \xhookrightarrow{} T$ where $T$ is a set of terms with $T \cap \Consts(\Sigma) = \emptyset$.
\end{definition}

\begin{proposition}
\label{bcq-invariant-under-sigma-preserving-renaming}
  If $Q$ is a Boolean conjunctive query and $\sigma$ is $\Sigma$-preserving renaming on an instance $\mathcal{D}$, then $\mathcal{D} \cup \Sigma \models Q$ if and only if $\sigma(\mathcal{D}) \cup \Sigma \models Q$.
  \begin{proof}
    If we extend $\sigma$ to all of $\Terms(\SCTree{\mathcal{D}}{\Sigma})$ by defining $$\sigma'(t) =
    \begin{cases}
      \sigma(t) & \text{if } t \in \Consts(\mathcal{D}) \setminus \Consts(\Sigma) \\
      t & \text{otherwise}
    \end{cases}$$
    Then $\SCTree{\sigma'(\mathcal{D})}{\Sigma}$ is an isomorphic image of $\SCTree{\mathcal{D}}{\Sigma}$ under $\sigma'$. Now apply \Cref{sctree-soundness-completeness}.
  \end{proof}
\end{proposition}

\begin{remark}
  In \Cref{bcq-invariant-under-sigma-preserving-renaming}, we require that the renaming $\sigma$ \emph{preserves} all constants in $\Sigma$. This is because \begin{itemize}
    \item if $c \in \Consts(\Sigma)$ is renamed to some other constant by $\sigma$, then a rule in $\Sigma$ that fired in $\SCTree{\mathcal{D}}{\Sigma}$ may no longer fire in $\SCTree{\sigma(\mathcal{D})}{\Sigma}$ thereby invalidating the $(\Longrightarrow)$ implication, and
    \item if $t \in \Terms(\mathcal{D})$ is renamed to a constant in $\Sigma$, then a rule that did not fire in $\SCTree{\mathcal{D}}{\Sigma}$ may fire in $\SCTree{\sigma(\mathcal{D})}{\Sigma}$, invalidating $(\Longleftarrow)$ direction.
  \end{itemize}
\end{remark}

\begin{definition}
  We say that two instances $\mathcal{D}_1, \mathcal{D}_2$ are \emph{$\Sigma$-renaming-equivalent} (written $\mathcal{D}_1 \cong_\Sigma \mathcal{D}_2$) if there exists a $\Sigma$-preserving renaming $\sigma$ with $\sigma(\mathcal{D}_1) = \mathcal{D}_2$. It is easy to see that $\cong_\Sigma$ is an equivalence relation.
\end{definition}

We are ready to present a query-answering procedure \Cref{basic-query-answering-procedure} based on the intuition of \Cref{remark-towards-query-answering-procedure}. Note that, in $\textsc{EntailsConnectedBCQ}$, we can scan through all equivalence classes $[\mathcal{D}]_{\cong_\Sigma}$ of bags in $\SCTree{\mathcal{D}}{\Sigma}$ by a depth-first search, since
\begin{itemize}
  \item there are only finitely many such classes, and
  \item for each such $\cong_\Sigma$-equivalence class $\mathcal{E}$, there exists a path $v_1, \ldots, v_n$ from the root node of $\SCTree{\mathcal{D}}{\Sigma}$ such that
  \begin{enumerate}
    \item none of $\mu(v_1), \ldots, \mu(v_n)$ are $\cong_\Sigma$-equivalent
    \item $[\mu(v_n)]_{\cong_\Sigma} = \mathcal{E}$
  \end{enumerate}
  because we can always shorten a path not satisfying (1) by replacing a segment $v_i, \ldots, v_{i+m}$ such that $\mu(v_i) \cong_\Sigma \mu(v_{i+m})$ with just $v_i$, and then replacing all of $v_{i+m+1}, \ldots, v_n$ by their $\cong_\Sigma$-equivalent copies in the subtree rooted at $v_i$.
\end{itemize}

One can first prove termination and correctness of \Cref{basic-query-answering-procedure} for all connected BCQs by induction on the number of bound variables and recursively applying \Cref{recursive-connected-bcq-entailment}. It is then straightforward to see, by applying \Cref{base-connected-query-decomposition}, that \Cref{basic-query-answering-procedure} produces all valid answers to a general conjunctive query.

\begin{algorithm}
\caption{Basic query answering procedure}
\label{basic-query-answering-procedure}
\begin{algorithmic}[1]
\State // computes if $\mathcal{D} \cup \Sigma \models Q$ for connected BCQ $Q$
\Procedure{EntailsConnectedBCQ}{$\mathcal{D}$, $\Sigma$, connected BCQ $Q$}
  \ForAll{equivalence class $[\mathcal{G}]_{\cong_\Sigma}$ of bags in $\SCTree{\mathcal{D}}{\Sigma}$}
    \If{\textsc{IsSuccessfulBranchingPoint}($\mathcal{G}$, $\Sigma$, $Q$)}
      \State \textbf{return true}
    \EndIf
  \EndFor
  \State \textbf{return false}
\EndProcedure
\State
\Procedure{IsSuccessfulBranchingPoint}{$\mathcal{D}$, $\Sigma$, connected BCQ $Q$}
  \ForAll{nonempty partial map $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D})$}
    \If{\textsc{SatisfiedWith}($\mathcal{D}$, $\Sigma$, $Q$, $\sigma_\mathrm{partial}$)}
      \State \Return{\textbf{true}}
    \EndIf
  \EndFor
  \State \Return{\textbf{false}}
\EndProcedure
\State
\State // computes if the query is satisfied with a partial substitution $\sigma_\mathrm{partial}$
\Procedure{SatisfiedWith}{$\mathcal{D}$, $\Sigma$, $Q$, $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D})$}
  \State \textbf{require} $\dom{\sigma_\mathrm{partial}} \supseteq FV(Q)$
  \State $\mathcal{D}_\mathrm{Dsat} \gets \textsc{DatalogSaturate}(\ASatRules{\Sigma}, \mathcal{D})$
  \State $\mathrm{baseSatisfied} \gets \mathcal{D}_\mathrm{Dsat} \models \Baseq{Q}{\sigma_\mathrm{partial}}$
  \State $C_1, \ldots, C_n \gets$ $Q$-connected components of $\Vars(Q) \setminus \sigma_\mathrm{partial}$
  \State $\mathrm{allComponentsSatisfied} \gets \bigwedge_{i = 1}^n$
  \State \hskip1.5em \textsc{EntailsConnectedBCQ}($\mathcal{D}_\mathrm{Dsat}$, $\Sigma$, $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$)
  \State \Return{baseSatisfied \textbf{and} allComponentsSatisfied}
\EndProcedure
\State
\Procedure{AnswerConjunctiveQuery}{$\mathcal{D}$, $\Sigma$, conjunctive query $Q$}
  \ForAll{substitution $\alpha: FV(Q) \rightarrow \Consts(\mathcal{D})$}
    \If{\textsc{SatisfiedWith}($\mathcal{D}$, $\Sigma$, $Q$, $\alpha$)}
      \State \textbf{output} $\alpha$ as an answer
    \EndIf
  \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\newpage
\chapter{Deriving a Rewriting}\label{deriving-a-rewriting}

In \Cref{characterising-query-entailment-under-gtgds}, we develop \Cref{basic-query-answering-procedure} for producing all answers to a conjunctive query over single-headed GTGDs.

However, because of high data complexity, the algorithm is impractical for query-answering purposes: We have to explore a part of $\SCTree{\mathcal{D}}{\Sigma}$ for every single substitution $\alpha: FV(Q) \rightarrow \Consts(\mathcal{D})$. So instead, we aim to use \Cref{basic-query-answering-procedure} as a stepping stone to devising a Datalog rewriting that works for arbitrary input $\mathcal{D}$.

The first important observation is that the entailment of a subquery in a proper subtree of $\SCTree{\mathcal{D}}{\Sigma}$ only depends on a tiny fraction of $\mathcal{D}$.

More precisely, suppose that a connected subquery $Q_\mathrm{sub}$ is witnessed by a subtree $T_c$ of $\SCTree{\mathcal{D}}{\Sigma}$ rooted at a child $c$, which is obtained by firing an existential rule $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ together with a substitution $\sigma: \vec{x} \rightarrow \Terms(\mathcal{D})$. That is, there is a query homomorphism $Q_\mathrm{sub} \rightarrow T_c$ mapping all variables in $Q_\mathrm{sub}$ to nulls in $T_c$. If we let $\mathcal{D'}$ be a subset of $\mathcal{D}$ formed by extracting facts in $\mathcal{D}$ that are either
\begin{itemize}
  \item used in the substituted body $\sigma(\beta)$, or
  \item inherited to $c$, i.e. facts whose applied terms are all in $\sigma(H)$,
\end{itemize}
then we can still fire $\tau$ with $\sigma$ in $\SCTree{\mathcal{D'}}{\Sigma}$ to obtain a node $c'$. Moreover, by the construction of $\mathrm{SCtree}$, the subtree $T_{c'}$ rooted at $c'$ and $T_c$ are isomorphic, and in particular, there remains to be a query homomorphism $Q_\mathrm{sub} \rightarrow T_{c'}$. Ultimately, if we write $K$ for the maximum arity of predicates in $\Sigma \cup Q$, we only need a $(K, \Sigma)$-small set of facts to entail a subquery in a proper subtree.

Moreover, by \Cref{bcq-invariant-under-sigma-preserving-renaming}, we are only interested in the \emph{structure} of the $(K, \Sigma)$-small instance that is needed to satisfy a subquery. For example, if we have found out that an instance $\{R(c_1, c_2), R(c_2, r_1)\}$ is sufficient to entail a subquery $\exists z.\ T(c_2, r_2, z)$ where only $r_1$ and $r_2$ are constants in $\Sigma$, then we can deduce that $\forall x_1, x_2.\ R(x_1, x_2) \wedge R(x_2, r_1) \rightarrow \exists z.\ T(x_2, r_2, z)$.

With these observations in mind, we adopt the following strategy for building a rewriting.

\begin{itemize}
  \item Start with an atomic saturation $\ASatRules{\Sigma}$ of $\Sigma$.
  \item For each (\emph{not} necessarily maximal) $Q$-connected nonempty set $C$ of bound variables, introduce an intensional predicate $\mathrm{Subgoal}_C$, which asserts that a subquery induced by $C$ is satisfied by some partial substitution.
  \item For each \emph{local instance} $I$ (to be defined in \Cref{local-instances-and-the-subquery-entailment-problem}), which represents a $(K, \Sigma)$-small structure in the base instance, decide if $I$ contains enough facts to entail a subquery $C$. If so, add a rule roughly of the form $I \rightarrow \mathrm{Subgoal}_C$.
  \item Finally, add all rules that \emph{integrate} subgoals into the goal atom.
\end{itemize}

\section{Local Instances and the Subquery Entailment Problem}
\label{local-instances-and-the-subquery-entailment-problem}

% TODO: define the notion of "subquery entailment instance" and the "subquery entailment problem".
% TODO: describe a DP algorithm for deciding the subquery entailment problem, in line with \Cref{basic-query-answering-procedure}.

\section{The Rewriting Algorithm}

% TODO: present an algorithm. if time permits, add a correctness proof
%       and the runtime complexity analysis

\newpage
\chapter{Implementation, Testing and Evaluation}

% TODO: talk about the implementation architecture and briefly indicate how the user can try using the built jar

% TODO: talk about test queries which have "simply-connected" hypergraph structures (is this what people call "acyclic"? Check.)

\newpage
\chapter{Further Discussion and Conclusion}

\section{Future Work}

\section{Conclusion}

\printbibliography

\end{document}
