\documentclass[12pt]{report}

\usepackage[a4paper, margin=1.3in]{geometry}
\usepackage[maxnames=10]{biblatex}
\usepackage{setspace}
\usepackage[labelfont=bf]{caption}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[dvipsnames]{xcolor}
\usepackage{svg}

\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}

\hypersetup{
  colorlinks=true,
  linktoc=section,
  linkcolor=RoyalBlue,
  citecolor=RoyalBlue,
  urlcolor=RoyalBlue,
  linkbordercolor=white,
}

% Tell Cref how to reference an algorithm
\crefname{algorithm}{Algorithm}{Algorithms}
\Crefname{algorithm}{Algorithm}{Algorithms}

% settings for amsthm package
% apply chapter-wise theorem numbering for theorems
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

% The following are the numbered elements with "definition style" (i.e. non-italic)
\theoremstyle{definition}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}

% Load `.bib` file
\addbibresource{references.bib}

% Symbol definitions
\def\FV{{\mathrm{FV}}}
\def\Vars{{\mathrm{Vars}}}
\def\Consts{{\mathrm{Consts}}}
\def\Terms{{\mathrm{Terms}}}
\def\Nulls{{\mathrm{Nulls}}}
\def\Predicates{{\mathrm{Predicates}}}
\newcommand{\Arity}[1]{\ensuremath{\normalfont{\operatorname{Arity}} \left( #1 \right)}}
\newcommand{\dom}[1]{\ensuremath{\normalfont{\operatorname{dom}} \left( #1 \right)}}
\newcommand{\range}[1]{\ensuremath{\normalfont{\operatorname{range}} \left( #1 \right)}}
\newcommand{\ARew}[1]{\ensuremath{\normalfont{\textsc{ARew}} \left( #1 \right)}}
\newcommand{\BaseVars}[1]{\ensuremath{\normalfont{\textrm{BaseVars}} \left( #1 \right)}}
\newcommand{\NullVars}[1]{\ensuremath{\normalfont{\textrm{NullVars}} \left( #1 \right)}}
\newcommand{\SCTree}[2]{\ensuremath{\normalfont{\textrm{SCTree}} \left( #1, #2 \right)}}
\newcommand{\Subq}[3]{\ensuremath{\normalfont{\textrm{Subq}} \left( #1, #2, #3 \right)}}
\newcommand{\Commq}[2]{\ensuremath{\normalfont{\textrm{Commq}} \left( #1, #2 \right)}}
\newcommand{\LNames}[1]{\ensuremath{\normalfont{\textrm{LNames}} \left( #1 \right)}}
\newcommand{\LRealz}[2]{\ensuremath{\normalfont{\textrm{LRealz}}_{ #1 } \left( #2 \right)}}
\newcommand{\SubgoalRule}[1]{\ensuremath{\normalfont{\textrm{SubgoalRule}} \left( #1 \right)}}

\title{Rewriting Conjunctive Queries \\ Under Guarded TGDs}
\author{Ryosuke Kondo}
\date{May 2023}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

\section*{Abstract}

\newpage
\chapter{Introduction}
\label{introduction}

\section{Background}

Consider the following situation: (TODO; Think about some OMQA instance where two independent parties provide a data over which we would like to perform an existential join query.)

We would now like to find out (TODO; insert here the query content in English). This amounts to finding all \emph{answers} to a first-order existential sentence (TODO; insert here the query in first-order language), where each answer is a \emph{substitution} mapping free variables (TODO) to constants in data sources that make the sentence true.

Unlike querying a single relational database, it is not sufficient to perform a non-existential join query (TODO; insert here the query with existentials stripped away) and project the resulting tuples to ignore uninteresting components. Even though no constant in the input database matches variables in the partially-applied query (TODO; insert here a partially-applied query), we can deduce from the constraints that there must be some \emph{unknown} values that matches (TODO; insert here a partially-applied query).

In general, the problem of answering queries given (1) a collection of \emph{incomplete} data sources, (2) a finite set of \emph{data integration rules} that can derive the existence of new tuples and (3) a conjunctive query (CQ) is called Ontology-Mediated Query Answering (OMQA) \cite{bienvenu16}.

Data integration rules in OMQA problem instances are often written as Tuple-Generating Dependencies (TGDs), which are first-order sentences of the form $\forall \vec{x}.\ \Phi(\vec{x}, \vec{c}) \rightarrow \exists \vec{y}.\ \Psi(\vec{x}, \vec{y}, \vec{c}')$. In the example above, for instance, the rules can be translated into logical formulae (TODO: translate the rules into TGDs). Formulated this way, we can think of OMQA problems as finding all assignments $\sigma$ of free variables in the input query that validate the logical entailment relation $\mathcal{D} \cup \Sigma \models \sigma(Q)$, where $\mathcal{D}$ is the conjunction of all records present in data sources, $\Sigma$ is the data integration rules and $Q$ is the input CQ.

Unfortunately, however, OMQA problems with general TGDs turned out to be undecidable \cite{beeri_vardi_1981}. In response to this, \cite{cali_gottlob_kifer_2013} identified \emph{Guarded TGDs} (GTGDs) as a subclass of TGDs that leaves OMQA problems decidable, yet expressive enough to contain several classes of description logics.

\section{Previous Works}

Despite OMQA problems over GTGDs being known to be decidable for several years, only a small number of work have been done to develop computationally tractable algorithms for these problems. A recent work \cite{kappelmann_2019} suggested that we can efficiently rewrite a set of GTGD rules into a so-called \emph{Datalog saturation} of it, which is a set of existential-free TGDs that is "equivalent" to the original rule set for existential-free queries. The rewriting algorithm has been improved, implemented and evaluated in \cite{benedikt_buron_germano_kappelmann_motik_2022}. 

(TODO: include a diagram indicating the scheme of how Datalog saturation is incorporated into OMQA)

Even though the implementation by \cite{benedikt_buron_germano_kappelmann_motik_2022} only supports atomic queries out-of-the-box, we can reduce any \emph{acyclic} existential queries into a few guarded rules and a single goal atom containing just the free variables in the original query. For the (TODO: reference to the example given at the beginning of Section 1.1) query, we can add a (TODO)-ary goal predicate $\mathrm{Goal}(-, -)$ and rules (TODO: apply the reduction). However, such reduction does not apply to cyclic queries (e.g. a \emph{triangle query} $\exists x,y,z.\ R(w, x, y) \land S(y, z) \land S(z, x)$) in general.

(TODO: The following two paragraphs clearly do not fit here, but I think they should be present in the introduction, or else the exact problem I worked on is very difficult to communicate. Reorganize?)

It has been known that the entailment $\mathcal{D} \cup \Sigma \models \sigma(Q)$ holds if and only if $\sigma(Q)$ is witnessed by the \emph{chase} of $\mathcal{D}$, which, informally speaking, is the result of \emph{repairing} $\mathcal{D}$ by generating tuples using rules in $\Sigma$ infinitely many times. % citation needed

Moreover, it has also been known that there exists a \emph{Datalog rewriting} of a finite set of GTGD rules and an arbitrary CQ \cite{barany_benedikt_cate_2013}. We will refer the problem of finding a Datalog rewriting of a GTGD rule set and a CQ by \emph{GTGD-Datalog Rewriting}. Note that Datalog-saturating a GTGD rule set is a special case of GTGD-Datalog Rewriting problem where the query is always atomic.

\emph{To the best of my knowledge, however, no work has implemented a query answering procedure for general CQs under GTGDs}. Given that many real-world database queries are cyclic (TODO: evidence?), limiting ourselves to acyclic existential queries may pose issues on smooth adoptation of OMQA systems.

\section{Contribution of This Work}

The contribution of this work is threefold:

\begin{itemize}
  \item By examining the structure of chases, I derived a novel reduction of GTGD-Datalog Rewriting problem into exponentially many small instances of GTGD query answering problems with \emph{Boolean} CQs (BCQs), which no longer have free variables.
  \item By making use of properties of chases, I demonstrate how BCQ answering over GTGD rules can be decided using a simple product of two \emph{tree automata}. By eliminating redundant nondeterminism in these automata, I derived a novel recursive procedure for deciding BCQ entailment problems, which can be memoized to further speed up subsequent BCQ answerings.
  \item Last but not least, I provide a Java implementation of the former two algorithms which, when combined, can be assembled into an OMQA system.
\end{itemize}

\section{Outline of This Report}

(TODO: use in-doc links)

In Chapter 2, I introduce basic terminologies and results that will be used throughout the report.

In Chapter 3, I revisit the notion of "tree-like chase proof" and introduce the notion of "shortcut chases" (TODO: I'm pretty sure this have been defined elsewhere; find a literature if possible and cite here?) with a few diagrams. I then provide a simple analysis of how answers of the input query must be embedded into the chase tree, and argue that for rewriting purpose it is sufficient to decide whether a given rule plus a guarded set is "large enough" to entail a Boolean conjunctive subquery of a particular form.

In Chapter 4, I begin with introducing nondeterministic finitely-commit-tree automata. We then discuss the most natural way to decide BCQ entailment using a formal product of "wildly nondeterministic commit query automaton" and "naive chase automaton". I show that, by carefully balancing the role of these two automata, we can make the chase automaton deterministic, and argue that we can translate the so-obtained automaton into a recursive decision algorithm.

In Chapter 5, we discuss the details of implementation and its verification. I provide some benchmarks to observe how the algorithm runtime increases as the input becomes larger.

We conclude the report with an overview, and discuss some weakness of the algorithm which may be improved in future studies.

\newpage
\chapter{Preliminaries}

This chapter introduces terminologies and notations, which we will use throughout the report.

\section{Formulas}

We fix countably infinite collections of \emph{constants}, \emph{variables} and \emph{nulls}. Nulls are similar to variables but play a similar role as Skolem constants (at the beginning of \Cref{characterising-query-entailment-under-gtgds}, we will see examples illustrating the use of nulls). A \emph{term} is either a constant, a variable or a null.

We also fix a countably infinite set of \emph{predicates}. A predicate $P$ has its associated arity $\Arity{P} \in \mathbb{N}_{\geq 0}$. An \emph{atom} is a string of the form $P(t_1, \ldots, t_{\Arity{P}})$, where each $t_i$ is a term. A \emph{fact} is an atom not containing a variable, and a \emph{base fact} is a fact not containing nulls. We write $\Terms(S)$, $\Consts(S)$, $\Vars(S)$ and $\Nulls(S)$ for the sets of terms, constants, variables and nulls appearing in an object $S$ (such as a conjunction of atoms).

A \emph{tuple-generating dependency (TGD)} is a formula of the form $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ \eta$, where $\beta$ and $\eta$ are conjunctions of null-free atoms containing variables from $\vec{x}$ and $\vec{x} \cup \vec{y}$ respectively. The conjunctions $\beta$ and $\eta$ are called the \emph{body} and the \emph{head} of $\tau$, respectively. The set $\Vars(\beta) \cap \Vars(\eta)$ of variables appearing in both the body and the head of $\tau$ is called the \emph{frontier} of $\tau$.

A TGD $\forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ \eta$ without an existential variable (i.e. $\vec{y} = \emptyset$) is said to be \emph{full}. Full TGDs are also called \emph{Datalog} rules. Conversely, a non-full rule is said to be \emph{existential}. A finite set of Datalog rules is called a \emph{Datalog program}.

We say that a conjunction $A_1 \wedge \ldots \wedge A_n$ of atoms is \emph{guarded} if there is an atom $A_i$ with $\Vars(A_i) = \Vars(A_1 \wedge \ldots \wedge A_n)$, and that a TGD is a \emph{guarded TGD (GTGD)} if its body $\beta$ is guarded. A GTGD $\forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ \eta$ is \emph{single-headed} if the head $\eta$ only contains a single atom.

\begin{remark}
  Note that a full rule $\forall \vec{x}.\ \beta \rightarrow H_1 \wedge \ldots \wedge H_n$ can always be split into $n$ rules $\forall \vec{x}.\ \beta \rightarrow H_i$ for $1 \leq i \leq n$. We will, therefore, implicitly treat all full rules as single-headed rules.
\end{remark}

\begin{remark}
  We can also split a non-single-headed existential rule $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H_1 \wedge \ldots \wedge H_n$, but only if we introduce a new predicate. More precisely, suppose that $\vec{z} \subseteq \vec{x}$ is the frontier of $\tau$, then we can turn $\tau$ into two rules
  \begin{itemize}
    \item $\forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ I(\vec{z}, \vec{y})$, and
    \item $\forall \vec{z}, \vec{y}.\ I(\vec{z}, \vec{y}) \rightarrow H_1 \wedge \ldots \wedge H_n$, which is full.
  \end{itemize}

  In general, a set $\Sigma$ of GTGDs can be turned into a set of single-headed GTGDs if we introduce an intermediate predicate for each existential rule in $\Sigma$.
  \qed
\end{remark}

A \emph{conjunctive query} is a formula of the form $\exists z_1, \ldots, z_n.\ A_1 \wedge \ldots \wedge A_m$, where $n \geq 0$, $m \geq 1$, and each $A_i$ is an atom. We write $\FV(Q)$ for the set of free variables in $Q$. A conjunctive query is said to be \emph{Boolean} if $\FV(Q) = \emptyset$.

\section{Database Instances and Homomorphisms}

We now turn our attention to a representation of a relational database. A \emph{(database) instance} is a collection of facts. A base (database) instance is a collection of base facts. We often regard a database instance as a single conjunction of facts. For example, we identify an instance $\{ R(c_1, c_3), T(c_2, c_3, c_3) \}$ with a conjunction $R(c_1, c_3) \wedge T(c_2, c_3, c_3)$.

We use \emph{homomorphisms} to describe how an instance satisfies a conjunctive query.

An \emph{instance homomorphism} $\sigma: \mathcal{D} \rightarrow \mathcal{D}'$ from an instance $\mathcal{D}$ to another instance $\mathcal{D}'$ is an ``embedding" of $\mathcal{D}$ into $\mathcal{D}'$. More precisely, $\sigma$ is a mapping $\sigma: \Nulls(\mathcal{D}) \rightarrow \Terms(\mathcal{D}')$, such that for every fact $F \in \mathcal{D}$, $\sigma(F) \in \mathcal{D}'$.

Similarly, a \emph{query homomorphism} $\sigma: Q \rightarrow \mathcal{D}$ from a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ to an instance $\mathcal{D}$ is a mapping $\sigma: \Vars(Q) \rightarrow \Terms(\mathcal{D})$ such that $\sigma(A_j) \in \mathcal{D}$ for each $j \in J$.

We say that an instance $\mathcal{D}$ \emph{satisfies} a Boolean conjunctive query $Q$, written $\mathcal{D} \models Q$, if there exists a query homomorphism $\sigma: Q \rightarrow \mathcal{D}$. We also say that the instance $\mathcal{D}$ together with a set $\Sigma$ of TGDs \emph{entails} $Q$, written $\mathcal{D} \cup \Sigma \models Q$, if for every extension $\mathcal{D}_\mathrm{ext}$ of $\mathcal{D}$ satisfying $\Sigma$, $\mathcal{D}_\mathrm{ext}$ satisfies $Q$. Note that this definition of query satisfaction and entailment is consistent with the ordinary model-theoretic interpretation of $\models$ relation.

\section{Datalog Saturation}

Consider the following problem:

\begin{problem}
   Given an existential-free conjunctive query $Q$, an input database $\mathcal{D}$ and a Datalog program $P$, find all substitutions (each of which is an \emph{answer} to the query) $\alpha: \FV(Q) \rightarrow \Consts(\mathcal{D})$ such that $\mathcal{D} \cup P \models \alpha(Q)$.
\end{problem}

Several algorithms for this problem are known, and \cite{bancilhon_ramakrishnan_1986} compared a few classic algorithms. One of the simplest is the \emph{Naive Evaluation} (\Cref{naive-evaluation-algorithm}). Roughly speaking, we keep adding tuples produced by rules in $P$ to the input database until we reach a fix-point. We then evaluate $Q$, which is merely a join query, on the populated database to obtain all answers.

\begin{algorithm}
\caption{Answering Datalog query using Naive Evaluation}
\label{naive-evaluation-algorithm}
\begin{algorithmic}[1]
\Procedure{DatalogSaturate}{Datalog program $P$, input database $\mathcal{D}$}
  \State $\mathcal{D}_\mathrm{current} \gets \mathcal{D}$
  \While{true}
    \State $\mathcal{D}_\mathrm{next} \gets \mathcal{D}_\mathrm{current}$
    \ForAll{$r \in P$}
      \ForAll{$\sigma \in $ result of matching the body of $r$ on $\mathcal{D}_\mathrm{current}$}
        \State add all head atoms of $r$ substituted with $\sigma$ to $\mathcal{D}_\mathrm{next}$
      \EndFor
    \EndFor
    \State
    \If{$\mathcal{D}_\mathrm{next} \neq \mathcal{D}_\mathrm{current}$}
      \State $\mathcal{D}_\mathrm{current} \gets \mathcal{D}_\mathrm{next}$
    \Else
      \State \Return{$\mathcal{D}_\mathrm{current}$}
    \EndIf
  \EndWhile
\EndProcedure
\State
\Procedure{AnswerDatalogQuery}{$P$, $\mathcal{D}$, $\exists$-free query $Q$}
  \State \Return{result of running the join query $Q$ on $\textsc{DatalogSaturate}(P, \mathcal{D})$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

We call the database instance $\textsc{DatalogSaturate}(P, \mathcal{D})$ the \emph{Datalog saturation of $\mathcal{D}$ with $P$}. Intuitively, a Datalog saturation results from \emph{supplementing} the input instance by adding all (but nothing other than) facts derivable from the original instance.

For a general set $\Sigma$ of GTGDs, we can compute a Datalog program, which we call an \emph{atomic rewriting}, that gives the same answers as $\Sigma$ for atomic queries. More precisely,

\begin{definition}
  Let $\Sigma$ be a finite set of GTGDs. We say that a Datalog program $P$ is an \emph{atomic rewriting} of $\Sigma$ if for every instance $\mathcal{D}$ and every fact $F$, $\mathcal{D} \cup \Sigma \models F$ if and only if $\mathcal{D} \cup P \models F$.
\end{definition}

A recent work \cite{benedikt_buron_germano_kappelmann_motik_2022} implemented an algorithm called \emph{Guarded-saturation} for computing an atomic rewriting of an arbitrary GTGD set. For this report, we fix an implementation in Guarded-saturation and call its output \emph{the} atomic rewriting $\ARew{\Sigma}$ of $\Sigma$.

\section{Problem Formulation}

% Define output of GSat as "atomic rewriting" of a GTGD set
Our ultimate goal is to answer the following problem.

\begin{problem}[GTGD-CQ Answering]
\label{GTGD-CQ-Answering}
  Given a finite set $\Sigma$ of GTGDs, a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ and a base instance $\mathcal{D}$, what are the \emph{answers} to $Q$ under $\Sigma$ and $\mathcal{D}$, i.e. substitutions $\alpha: \FV(Q) \rightarrow \Consts(\mathcal{D})$ such that $\mathcal{D} \cup \Sigma \models \alpha(Q)$?
\end{problem}

It is known that a conjunctive query under GTGDs admits \emph{Datalog rewritings} \cite{barany_benedikt_cate_2013}. These are Datalog programs with a designated \emph{goal atom} that, when run on any base instance, give the same set of answers as the original rule-query pair. More precisely:

\begin{definition}
  A \emph{Datalog rewriting} of a GTGD-CQ pair $(\Sigma, Q)$ is a Datalog program $\Sigma_\mathrm{Datalog}$ together with an atomic query $Q_\mathrm{atomic}$ with $\FV(Q_\mathrm{atomic}) = \FV(Q)$, such that for every base instance $\mathcal{D}$ and a substitution $\alpha: \FV(Q) \rightarrow \Consts(\mathcal{D})$ for $Q$, $$\mathcal{D} \cup \Sigma \models \alpha(Q) \textit{ if and only if } \mathcal{D} \cup \Sigma_\mathrm{Datalog} \models \alpha(Q_\mathrm{atomic}).$$
  We call $Q_\mathrm{atomic}$ the \emph{goal atom} in the Datalog rewriting.
  \qed
\end{definition}

In order to answer \Cref{GTGD-CQ-Answering}, it is desirable to run a Datalog rewriting of the pair $(\Sigma, Q)$ on $\mathcal{D}$ instead of directly verifying $\mathcal{D} \cup \Sigma \models \alpha(Q)$ for every possible substitution $\alpha: \FV(Q) \rightarrow \Consts(\mathcal{D})$, since running a fixed Datalog program on $\mathcal{D}$ only takes time polynomial in the size of $\mathcal{D}$ \cite{dantsin_eiter_gottlob_voronkov_2001}.

This project aims to derive an algorithm that produces Datalog rewritings for arbitrary GTGD-CQ pairs. We achieve this using the atomic rewriting produced by the Guarded-saturation algorithm.

\newpage
\chapter{Characterising Query Entailment under GTGDs}
\label{characterising-query-entailment-under-gtgds}

\section{Tree-Like Chase Proofs}

In the presence of existential rules, an object known as the \emph{chase} represents a canonical \emph{completion} of a database concerning some data integration rules. Chases are constructed similarly to Datalog saturations by adding tuples produced by rules, except we need to replace existential variables with \emph{nulls}, which represent Skolem constants \cite{fagin_kolaitis_miller_popa_2005}.

As with Datalog saturations, the chase of an instance $\mathcal{D}$ gives all possible answers $\alpha: \FV(Q) \rightarrow \Consts(\mathcal{D})$ to a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$. That is, we can find all answers to $Q$ by evaluating a join query $\bigwedge_{j \in J} A_j$ on the chase and projecting $\vec{z}$ away.

However, with recursive rules\footnote{A TGD is recursive if a predicate appears both in the body and the head.} such as $R(x, y) \rightarrow \exists z.\ R(y, z)$, the chase procedure may have to be continued indefinitely, producing an infinite chase. Moreover, as one keeps populating the database instance with tuples regardless of whether they eventually affect query output, the chase lacks a structure with which we can reason about query entailments.

% TODO: which paper introduced tree-like chase proofs for Datalog+-?
To deal with this issue, \cite{benedikt_buron_germano_kappelmann_motik_2022} introduced the notion of \emph{tree-like chase proofs}, which essentially capture instants of ongoing chase processes. To precisely describe this, we will use the following terminology.

\begin{definition}
  A \emph{chase tree} is a pair of a (potentially infinite) rooted directed tree $T$ together with a function $\mu$ mapping each vertex $v \in T$ to a set of facts (possibly with nulls). We usually refer to the instance $\mu(v)$ as a \emph{bag of facts at $v$} to distinguish it from the input base instance.
  
  We will often identify a chase tree $(T, \mu)$ with the set $\bigcup_{v \in T} \mu(v)$ of facts in it.
  \qed
\end{definition}

In this section, we focus on finite chase trees. The following definition incorporates ideas from \cite{benedikt_buron_germano_kappelmann_motik_2022} and \cite{kappelmann_2019}.

\begin{definition}
\label{tree-like-chase-proof}
  Given a set $\Sigma$ of single-headed GTGDs and a base instance $\mathcal{D}$, a \emph{tree-like chase proof over $\Sigma$ from $\mathcal{D}$} is a finite sequence of chase trees $C_1, \ldots, C_n$ such that
  \begin{itemize}
    \item $C_1 = (T, \mu)$ is a chase tree with a single vertex $v$ together with $\mu(v) = \mathcal{D}$.
    \item for each $i < n$, $C_{i + 1}$ is obtained from $C_i = (T, \mu)$ by applying one of the following transformation steps.
    \begin{itemize}
      \item \emph{a chase step} from a vertex $v \in T$ with $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ and a substitution $\sigma$ mapping $\vec{x}$ to terms in $\mu(v)$, provided that $\sigma(\beta) \subseteq \mu(v)$. The result $(T', \mu')$ of this step depends on whether $\tau$ is full, i.e. if $|\vec{y}| = 0$:
      \begin{itemize}
        \item If $\tau$ is full, we simply add the head atom $H$ of $\tau$ to the instance at $v$. That is, we keep $T' = T$, and set $\mu'(v) = \mu(v) \cup \sigma(H)$ while maintaining $\mu$ and $\mu'$ equal on $T \setminus \{v\}$.
        \item If $\tau$ is existential, we create a fresh child of $v$, put the generated tuple in it and \emph{inherit} facts from the parent bag. Formally, we first extend $\sigma$ to a substitution $\sigma'$ that maps variables in $\vec{y}$ to fresh nulls. We define the bag $I$ containing \emph{inherited facts} as $$I = \{ F \in \mu(v) \mid \Terms(F) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma) \}.$$ Finally, we prepare a fresh vertex $c$, form $T'$ by making $c$ a child of $v$, and extend $\mu$ to $\mu'$ with $\mu'(c) = \{\sigma'(H)\} \cup I$.
      \end{itemize}
      \item \emph{a propagation step} from a vertex $v \in T$ to an ancestor $a \in T$ of $v$ with a fact $F \in \mu(v)$, provided that $F \not\in \mu(a)$ and $\Terms(F) \subseteq \Terms(\mu(a)) \cup \Consts(\Sigma)$. The resulting chase tree is $(T, \mu')$, where $\mu'$ agrees with $\mu$ everywhere except at $a$, and $\mu'(a) = \mu(a) \cup \{F\}$.
    \end{itemize}
  \end{itemize}
  \qed
\end{definition}

A tree-like chase proof over $\Sigma$ from $\mathcal{D}$ represents a process of supplementing $\mathcal{D}$ according to $\Sigma$. We can derive new tuples using a chase step, stepping off to a child node when firing an existential rule. With a propagation step, we can retrieve a fact derived at a descendant node to its ancestor.

\begin{example}
\label{tree-like-chase-proof-example}
  Suppose that $\Sigma$ contains the following single-headed GTGDs, where $c_1$ is a constant.
  \[\begin{array}{rcrcl}
    \tau_1 &=& \forall x_1,x_2.\ A(x_1, x_2) &\rightarrow& \exists y.\ B(x_1, y) \\
    \tau_2 &=& \forall x_1,x_2.\ B(x_1, x_2) &\rightarrow& C(x_1, c_1) \wedge A(x_2, c_1) \\
    \tau_3 &=& \forall x_1,x_2.\ A(x_1, x_2) \wedge C(x_1, x_2) &\rightarrow& \exists y.\ D(x_2, y)
  \end{array}\]
  If we start with an instance $\mathcal{D} = \{A(c_4, c_1)\}$, we can perform a chase step with $\tau_1$, then chase with $\tau_2$, propagate a fact $C(c_4, c_1)$ to the root and finally fire $\tau_3$. We illustrate the process in \Cref{tree-like-chase-proof-example-diagram}.
  \qed
\end{example}

\begin{figure}[t]
  \centering
  \includesvg{./diagrams/tree-like-chase-proof-example.drawio.svg}
  \caption{A tree-like chase proof with rules in \Cref{tree-like-chase-proof-example}. At each stage, elements newly added to the chase tree are highlighted in red.}
  \label{tree-like-chase-proof-example-diagram}
\end{figure}

Note that we only propagate or inherit facts whose terms appear in the target node. Intuitively, such a restriction can be justified because the guardedness of rules in $\Sigma$ prohibits us from \emph{combining} unrelated terms into new tuples. We cannot hope to fire an existential rule from a node $a \in T$ in a meaningfully novel manner even if we transfer to $a$ a fact with terms not already present in $a$. That is, if we propagated a fact $F$ from $v$ to $a$ and could fire a rule $(\tau, \sigma)$ on $a$ \emph{using} $F$, we could have fired $(\tau, \sigma)$ on $v$ in the first place, provided that $v$ inherited enough facts related to $F$ from $a$\footnote{In fact, $a$ might have more facts with terms in $F$ than $v$ does due to propagation from cousin nodes of $v$. In that case, we could "re-derive" a cousin node $v'$ from $a$ in the same way as how we had derived $v$, and $v'$ should have as many facts related to an isomorphic copy of $F$ as $a$ does.}.

The restriction mentioned above makes the local structure of tree-like chase proofs \emph{small} in the following sense.

\begin{definition}
  Let $\Sigma$ be a set of GTGDs and $K \in \mathbb{N}$. We say that a bag $\mathcal{B}$ of facts is \emph{$(K, \Sigma)$-small} when $|\Terms(\mathcal{B}) \setminus \Consts(\Sigma)| \leq K$.
\end{definition}

\begin{proposition}[Tree-width of chase proofs]
\label{chase-proofs-tree-width}
  Let $\Sigma$ be a set of \emph{single-headed} GTGDs, $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ a tree-like chase proof over $\Sigma$ from $\mathcal{D}$. Let $K$ be the maximum arity of predicates that appear in $\mathcal{D} \cup \Sigma$. Then for every $1 \leq i \leq n$ and every non-root vertex $v$ of $T_i$, $\mu_i(v)$ is $(K, \Sigma)$-small. In particular, if $\mathcal{D}$ is $(K, \Sigma)$-small, all bags in $(T_i, \mu_i)$ are $(K, \Sigma)$-small.
  \begin{proof}
    By induction on $i$. The base case $i = 1$ is vacuous. We look at the rule used to derive $(T_{i+1}, \mu_{i+1})$ from $(T_{i}, \mu_{i})$ and examine the bag at the modified node.
    \begin{itemize}
      \item If the last step was a chase step with a full rule or a propagation step, no term set has been modified for any bag in the chase tree.
      \item If the last step was a chase step from a vertex $v \in T_i$ with an existential rule $\forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ and a substitution $\sigma$, we have added a new node $c$ under $v$. As $|\Terms(\sigma'(H))| \leq K$ and the inherited bag $I$ has $\Terms(I) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma)$,
      \begin{equation*}
        \begin{split}
          |\Terms(\mu_{i+1}(c)) \setminus \Consts(\Sigma)|
            &= |\Terms(\{\sigma'(H)\} \cup I) \setminus \Consts(\Sigma)| \\
            &\leq K.
        \end{split}
      \end{equation*}
    \end{itemize}
    When $\mathcal{D}$ is $(K, \Sigma)$-small, the result extends to the root node since no chase transformation modifies the term set of the root node.
  \end{proof}
\end{proposition}

At the same time, as long as conjunctive queries are concerned, tree-like chase proofs prove everything we can reason about the input database $\mathcal{D}$.

\begin{proposition}
\label{chase-proof-completeness}
  For any set $\Sigma$ of single-headed GTGDs, an instance $\mathcal{D}$ and a Boolean conjunctive query $Q$, there exists a tree-like chase proof $\ C_1, \ldots, C_n$ over $\Sigma$ from $\mathcal{D}$ such that $C_n \models Q$ if and only if $\mathcal{D} \cup \Sigma \models Q$.
  \begin{proof}[Proof (sketch)] $ $\par
    ($\Longrightarrow$, "soundness" of chase proofs): Suppose that $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ is a tree-like chase proof over $\Sigma$ from $\mathcal{D}$. For each $1 \leq i \leq n$, let $I_i = \bigcup_{v \in T_n} \mu_n(v)$ be the instance containing all facts in $(T_i, \mu_i)$. The sequence $I_1, \ldots, I_n$ is known as a \emph{chase sequence}, and \cite{fagin_kolaitis_miller_popa_2005} showed that $Q$ follows from $\mathcal{D}$ if there is a chase sequence ending with $I_n \models Q$.

    ($\Longleftarrow$, "completeness" of chase proofs): This direction is proven in \cite[Proposition 2.6.9]{kappelmann_2019}. The proof therein decomposes an ordinary chase sequence into a tree-like structure, and the decomposition is performed exactly as in \Cref{tree-like-chase-proof}.
  \end{proof}
\end{proposition}

\section{Shortcutting Chase Trees}

Tree-like chase proof is a powerful tool to reason about a fragment of a chase, but unlike a full chase, they do not constitute a model of $\mathcal{D} \cup \Sigma$. Therefore, we wish to construct a model that retains a tree-like structure.

Notice that during a chase proof, we only ever fire an existential rule from a node $v$ in the hope of either
\begin{itemize}
  \item retrieving back a fact to $v$ to accumulate as much facts as possible to $v$, or
  \item finding an existential witness to the query variable in the subtree of $v$.
\end{itemize}
We can immediately achieve the former objective by computing the Datalog saturation of the bag at $v$ using the atomic rewriting $\ARew{\Sigma}$ of $\Sigma$. This observation motivates the following definition.

\begin{definition}[Shortcutting Chase Trees]
  Let $\Sigma$ be a finite set of single-headed GTGDs and $\mathcal{D}$ an instance. We inductively define an infinite sequence $(T_0, \mu_0), (T_1, \mu_1), \ldots$ of chase trees as follows:
  \begin{itemize}
    \item $(T_0, \mu_0)$ is a chase tree with only the root vertex $r$ together with $$\mu_0(r) = \textsc{DatalogSaturate}(\ARew{\Sigma}, \mathcal{D}).$$
    \item For the inductive step, $(T_{i + 1}, \mu_{i + 1})$ is constructed by shortcut-chasing all leaves in the previous chase tree $(T_i, \mu_i)$.
    
    More precisely, let $L_i$ be the set of leaf nodes in $T_i$. For each $l \in L_i$, an existential rule $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ and a substitution $\sigma$ mapping $\vec{x}$ into $\Terms(\mu_i(l))$ such that $\sigma(\beta) \subseteq \mu_i(l)$, define
    \begin{itemize}
      \item $\sigma'$ as an extension of $\sigma$ that maps all variables in $\vec{y}$ to fresh nulls
      \item the bag $B_{l, \tau, \sigma}$ of facts \emph{inherited from $\mu_i(l)$ through $\tau$ and $\sigma$} as $$B_{l, \tau, \sigma} = \{ F \in \mu_i(l) \mid \Terms(f) \subseteq \Terms(\sigma'(H)) \cup \Consts(\Sigma) \}$$
    \end{itemize}
    We construct $T_{i+1}$ as an extension of $T_i$ by adding a vertex $c_{l, \tau, \sigma}$ as a child of $l$ for each such $l \in L_i$, $\tau$ and $\sigma$. We extend $\mu_i$ to $\mu_{i+1}$ by setting $$\mu_{i+1}(c_{l, \tau, \sigma}) = \textsc{DatalogSaturate}(\ARew{\Sigma}, \{ \sigma'(H) \} \cup B_{l, \tau, \sigma}).$$
  \end{itemize}
  Finally, the \emph{shortcutting chase tree $\SCTree{\mathcal{D}}{\Sigma}$ of $\mathcal{D}$ over $\Sigma$} is a chase tree defined as the limit $(\bigcup_{i = 0}^\infty T_i, \bigcup_{i = 0}^\infty \mu_i)$ of the sequence defined above.
  \qed
\end{definition}

\begin{example}
\label{sctree-simple-example}
  Consider the rules in \Cref{tree-like-chase-proof-example}. According to an implementation in \cite{Benedikt_Rewriting_the_Infinite}, the set $\Sigma'$ of the following two rules is an atomic rewriting of $\Sigma$.
  \[\begin{array}{ccrcl}
    \tau'_1 & = & \forall x_1, x_2.\ B(x_1, x_2) & \rightarrow & C(x_1, c_1) \wedge A(x_2, c_1) \\
    \tau'_2 & = & \forall x_1, x_2.\ A(x_1, x_2) & \rightarrow & C(x_1, c_1)
  \end{array}\]

  A first few layers of $\SCTree{\{ A(c_4, c_1) \}}{\Sigma}$ is illustrated in \Cref{sctree-simple-example-diagram}. The chase tree is continued indefinitely by chasing with existential rules and Datalog-saturating each layer with $\Sigma'$.
  \qed
\end{example}

\begin{figure}[t]
  \centering
  \includesvg{./diagrams/sctree-simple-example.drawio.svg}
  \caption{A shortcutting chase tree over an instance $\{ A(c_4, c_1) \}$ with rules in \Cref{tree-like-chase-proof-example}. The facts highlighted in red are obtained by Datalog-saturating the inherited bag with an atomic rewriting, and dotted boxes indicate substituted bodies used to fire an existential rule. Notice how the subtree rooted at $v_1$ can be obtained as a shortcutting chase of the bag at $v_1$, as remarked in \Cref{corecursiveness-of-sctree}.}
  \label{sctree-simple-example-diagram}
\end{figure}

The structure of a shortcutting chase tree is very similar to that of a chase proof.

\begin{proposition}
\label{each-bag-in-sctree-is-k-sigma-small}
  Let $\Sigma$ be a set of single-headed GTGDs and $\mathcal{D}$ an instance. Let $K$ be the maximum arity of predicates that appear in $\mathcal{D} \cup \Sigma$. Then every bag of facts at a non-root node of \emph{$\SCTree{\mathcal{D}}{\Sigma}$} is $(K, \Sigma)$-small. In particular, if $\mathcal{D}$ is $(K, \Sigma)$-small, all bags in $\SCTree{\mathcal{D}}{\Sigma}$ are $(K, \Sigma)$-small.
  \begin{proof}
    By the same analysis as in the proof of \Cref{chase-proofs-tree-width}.
  \end{proof}
\end{proposition}

Expectedly, $\SCTree{\mathcal{D}}{\Sigma}$ is a universal model for $\mathcal{D} \cup \Sigma$, since any finite subtree of $\SCTree{\mathcal{D}}{\Sigma}$ homomorphically embeds into some chase proof.

\begin{lemma}
\label{sctree-subtree-embeds-into-a-chase-proof}
  Let $\mathcal{D}$ be an instance and $\Sigma$ a finite set of single-headed GTGDs. Then for any finite rooted subtree $(T, \mu)$ of $\SCTree{\mathcal{D}}{\Sigma}$, there exists a tree-like chase proof $C_1, \ldots, C_n$ that admits an instance homomorphism $\sigma: (T, \mu) \rightarrow C_n$.
  \begin{proof}
    By induction on the structure of $(T, \mu)$.

    The base case is $T = \{r\}$, where $r$ is the root of $\SCTree{\mathcal{D}}{\Sigma}$. By \Cref{chase-proof-completeness}, we can construct a chase-proof $C_1, \ldots, C_n$ that aggregates all provable base facts to the root bag.

    For the inductive part, take a finite rooted subtree $(T, \mu)$ and a leaf $l$ of $T$, and suppose that $T \setminus \{l\}$ can be homomorphically mapped into the last chase tree in a proof $C_1, \ldots, C_n$. Let $(\tau, \sigma)$ be a pair of a rule and a substitution used to derive $l$.
    
    We extend the proof $C_1, \ldots, C_n$ by applying a chase step with $(\tau, \sigma)$ to create a child node $c \in C_{n+1}$. By \Cref{chase-proof-completeness}, we can derive all facts whose terms appear in the bag $c$. We have now obtained a chase proof $C_1, \ldots, C_{n+m}$ with $c$ saturated, so $(T, \mu)$ can be homomorphically mapped into $C_{n+m}$.
  \end{proof}
\end{lemma}

\begin{theorem}
\label{sctree-soundness-completeness}
  For a set $\Sigma$ of single-headed GTGDs, an instance $\mathcal{D}$ and a Boolean conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$, $\mathcal{D} \cup \Sigma \models Q$ if and only if $\SCTree{\mathcal{D}}{\Sigma} \models Q$.
  \begin{proof}[Proof] $ $\par
    ($\Longrightarrow$): Suppose $\mathcal{D} \cup \Sigma \models Q$. By \Cref{chase-proof-completeness}, there exists a tree-like chase proof $(T_1, \mu_1), \ldots, (T_n, \mu_n)$ of $Q$ from $\mathcal{D}$ over $\Sigma$. By induction on $1 \leq i \leq n$ and by the construction of $\SCTree{\mathcal{D}}{\Sigma}$, we can embed each $(T_i, \mu_i)$ into $\SCTree{\mathcal{D}}{\Sigma}$. Since $(T_n, \mu_n) \models Q$ and $(T_n, \mu_n)$ embeds into $\SCTree{\mathcal{D}}{\Sigma}$, $\SCTree{\mathcal{D}}{\Sigma} \models Q$.

    ($\Longleftarrow$): Suppose $\SCTree{\mathcal{D}}{\Sigma} \models Q$. Then there exists a homomorphism $\sigma:\nobreak Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$.
    
    We may pick a finite rooted subtree $(T, \mu)$ of $\SCTree{\mathcal{D}}{\Sigma}$ such that $\sigma$ restricts to $\sigma: Q \rightarrow (T, \mu)$. To do so, for each $j \in J$, let $V_j \in \SCTree{\mathcal{D}}{\Sigma}$ be a set of vertices whose bags contain the fact $\sigma(A_j)$. Choose $v_j \in V_j$ for each $j \in J$, and let $T_j$ be the set of all ancestors of $v_j$. Finally, let $T = \bigcup_{j \in J} T_j$.

    By applying \Cref{sctree-subtree-embeds-into-a-chase-proof} to $(T, \mu)$, there is a chase proof of $Q$ from $\mathcal{D}$ under $\Sigma$. By soundness of chase proofs (\Cref{chase-proof-completeness}, $\Longrightarrow$) we are done.
  \end{proof}
\end{theorem}

\begin{remark}
\label{corecursiveness-of-sctree}
  A shortcutting tree chase has a \emph{corecursive} structure: If we write $\mu$ for the bag assignment function of $\SCTree{\mathcal{D}}{\Sigma}$, then for any vertex $v \in \SCTree{\mathcal{D}}{\Sigma}$, the subtree $T_v$ of all descendants (including $v$ itself) of $v$ can be written as $T_v = \SCTree{\mu(v)}{\Sigma}$.
\end{remark}

\section{Query Satisfaction in Shortcutting Chase Trees}

We now discuss how the structure of the query constrains the structure of query homomorphisms into the shortcutting chase tree. By the end of this chapter, we will have derived a recursive query answering procedure, whose recursive structure will be exploited in \Cref{deriving-a-rewriting} to compute a Datalog rewriting.

A key observation is that, under a certain condition, a \emph{connected} set of variables produces a connected homomorphic image in $\SCTree{\mathcal{D}}{\Sigma}$. To make this intuition precise, we introduce the following terminology.

\begin{definition}
  Given a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$, we say that
  \begin{itemize}
    \item two variables $z_1, z_2$ bound in $Q$ are \emph{$Q$-adjacent} if some atom $A_j$ in $Q$ contains both $z_1$ and $z_2$
    \item a set $Z$ of variables bound in $Q$ are \emph{$Q$-connected} if for each pair $z_1, z_2 \in Z$ of variables, there is a finite sequence $x_1, \ldots, x_n$ of variables in $Z$ such that
    \begin{itemize}
      \item $x_1 = z_1$ and $x_n = z_2$
      \item for each $1 \leq i < n$, $x_i$ and $x_{i+1}$ are $Q$-adjacent
    \end{itemize}
  \end{itemize}

  For a subset $Z$ of $\vec{z}$, a \emph{$Q$-connected component of $Z$} is a $\subseteq$-maximal $Q$-connected nonempty subset of $Z$.

  Finally, $Q$ is a \emph{connected} conjunctive query if $\vec{z}$ is $Q$-connected.
  \qed
\end{definition}

A set $Z$ of bound variables is $Q$-connected if $Z$ is connected in the hypergraph corresponding to the structure of $Q$ (with $Z$ as the vertex set and atoms in $Q$ as the hyperedges), as illustrated in the following example.

\begin{figure}[ht]
  \centering
  \includesvg{./diagrams/query-connectedness-example.drawio.svg}
  \caption{The hypergraph corresponding to $Q$ in \Cref{query-connectedness-example}.}
\end{figure}

\begin{example}
\label{query-connectedness-example}
  Consider a conjunctive query
  \begin{align*}
    Q = \exists z_1,z_2,z_3,z_4,z_5,z_6.&\ S(z_1, z_2) \wedge S(z_1,z_3) \wedge R(z_2, z_3) \\
    &\wedge R(z_3, z_4) \wedge R(z_3, z_5) \wedge T(z_2, z_6, z_5).
  \end{align*}
  Then $\{z_1, z_3, z_4\}$ and $\{z_2, z_3, z_5\}$ are both $Q$-connected, but $\{z_1, z_2, z_4\}$ and $\{z_4, z_5\}$ are not. $Q$-connected components of $\{z_1, z_4, z_6, z_5\}$ are $\{z_1\}$, $\{z_4\}$ and $\{z_5, z_6\}$. $Q$ is a connected Boolean query.
  \qed
\end{example}

We are ready to state the observation.

\begin{proposition}
\label{term-subtree-is-connected-for-non-rule-constants}
  Let $\SCTree{\mathcal{D}}{\Sigma}$ be a shortcutting chase tree over an instance $\mathcal{D}$. Then for any $t \in \Terms(\SCTree{\mathcal{D}}{\Sigma}) \setminus \Consts(\Sigma)$, the set $V_t$ of vertices in $\SCTree{\mathcal{D}}{\Sigma}$ that contain $t$ forms a rooted subtree of $\SCTree{\mathcal{D}}{\Sigma}$.
  \begin{proof}
    Since $t \not\in \Consts(\Sigma)$, $t$ appears in a node only if it is
    \begin{itemize}
      \item inherited from the parent node
      \item a term in $\mathcal{D}$
      \item a null introduced at the node
    \end{itemize}
    Since no null is introduced at two different nodes, $V_t$ must be a rooted subtree of $\SCTree{\mathcal{D}}{\Sigma}$.
  \end{proof}
\end{proposition}

\begin{definition}
  A query homomorphism $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is said to be $\Consts(\Sigma)$-free if $\range{\sigma} \cap \Consts(\Sigma) = \emptyset$.
\end{definition}

\begin{lemma}[\emph{Homomorphic image of connected variables is connected}]
\label{image-of-connected-variables-is-connected}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query, $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ a $\Consts(\Sigma)$-free query homomorphism, and $Z$ a nonempty, $Q$-connected subset of $\vec{z}$. If we write $T_Z$ for the set of nodes in $\SCTree{\mathcal{D}}{\Sigma}$ whose bags contain a term in $\sigma(Z)$, then $T_Z$ is a rooted subtree of $\SCTree{\mathcal{D}}{\Sigma}$.
  \begin{proof}
    For each term $t \in \sigma(Z)$, let $V_t \subseteq \SCTree{\mathcal{D}}{\Sigma}$ be the set of nodes in which $t$ appears. We wish to see that $T_Z = \bigcup_{t \in \sigma(Z)} V_t$ is a rooted subtree of $\SCTree{\mathcal{D}}{\Sigma}$. Since $T_Z$ is nonempty, it suffices to show the connectedness of $T_Z$.

    So take two vertices $v_1, v_2 \in T_Z$, and let $z_1, z_2 \in Z$ be variables bound in $Q$ such that $v_i \in V_{\sigma(z_i)}$ for $i \in \{1, 2\}$. As $Z$ is $Q$-connected, there exists a sequence $z_1 = x_1, \ldots, x_n = z_2$ of variables in $Z$ such that $x_i$ and $x_{i+1}$ are $Q$-adjacent for each $1 \leq i < n$.

    For each $i$, there exists an atom $A$ containing both $x_i$ and $x_{i+1}$. As \newline $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is a query homomorphism, there exists a node $v$ in $\SCTree{\mathcal{D}}{\Sigma}$ that contains $\sigma(A)$. In particular, $v$ contains both $\sigma(x_i)$ and $\sigma(x_{i+1})$, so $V_\sigma(x_i) \cap V_\sigma(x_{i+1}) \neq \emptyset$.

    By \Cref{term-subtree-is-connected-for-non-rule-constants}, each $V_\sigma(x_i)$ is connected, so there is a path in $\SCTree{\mathcal{D}}{\Sigma}$ that joins $v_1$ and $v_2$ through intersections $V_\sigma(x_i) \cap V_\sigma(x_{i+1})$.
  \end{proof}
\end{lemma}

We will use \Cref{image-of-connected-variables-is-connected} to develop a query-answering procedure. To begin with, we define a way to split the query entailment checking problem into smaller problems by a partial guess of the query homomorphism.

\begin{definition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query and $\sigma_\mathrm{commit}: \Vars(Q) \rightharpoonup T$ a partial map from query variables to a set $T$ of terms. Let $\mathrm{BVars} = \dom{\sigma_\mathrm{commit}}$.

  We define the \emph{committed part $\Commq{Q}{\sigma_\mathrm{commit}}$ of $Q$ according to $\sigma_\mathrm{commit}$} as the variable-free query
  $$\Commq{Q}{\sigma_\mathrm{commit}} = \bigwedge_{\substack{j \in J \\ \Vars(A_j) \subseteq \mathrm{BVars}}} \sigma_\mathrm{commit}(A_j).$$

  For each $Q$-connected component $C$ of $(\vec{z} \setminus \mathrm{BVars})$, the \emph{subquery $\Subq{Q}{\sigma_\mathrm{commit}}{C}$ of $Q$ induced by $\sigma_\mathrm{commit}$ and $C$} is the connected Boolean conjunctive query defined by
  $$\Subq{Q}{\sigma_\mathrm{commit}}{C} = \exists \vec{C}. \bigwedge_{j \in J'} \sigma_\mathrm{commit}(A_j),$$
  where $$J' = \{ j \in J \mid \Vars(A_j) \subseteq C \cup \mathrm{BVars} \}.$$
  \qed
\end{definition}

\begin{figure}[ht]
  \centering
  \includesvg{./diagrams/query-decomposition-example.drawio.svg}
  \caption{Decomposition of the query from \Cref{query-connectedness-example} with partial map as in \Cref{bcq-decomposition-example}.}
  \label{bcq-decomposition-example-figure}
\end{figure}

\begin{example}
\label{bcq-decomposition-example}
  Let
  \begin{align*}
    Q = \exists z_1,z_2,z_3,z_4,z_5,z_6.&\ S(z_1, z_2) \wedge S(z_1,z_3) \wedge R(z_2, z_3) \\
    &\wedge R(z_3, z_4) \wedge R(z_3, z_5) \wedge T(z_2, z_6, z_5)
  \end{align*}
  as in \Cref{query-connectedness-example}. Suppose that $\sigma_\mathrm{commit}$ is given by \[\begin{array}{cccc}
    \sigma_\mathrm{commit}: &\Vars(Q) &\rightharpoonup &\{c_1, c_2, c_3\} \\
    &z_2 &\mapsto &c_1 \\
    &z_3 &\mapsto &c_3
  \end{array}\]
  then $\Commq{Q}{\sigma_\mathrm{commit}} = R(c_1, c_3)$. The split connected components are $C_1 = \{z_1\}$, $C_2 = \{z_4\}$ and $C_3 = \{z_5, z_6\}$, and their corresponding subqueries are
  \begin{align*}
    \Subq{Q}{\sigma_\mathrm{commit}}{C_1} &= \exists z_1.\ S(z_1, c_1) \wedge S(z_1, c_3) \\
    \Subq{Q}{\sigma_\mathrm{commit}}{C_2} &= \exists z_4.\ R(c_3, z_4) \\
    \Subq{Q}{\sigma_\mathrm{commit}}{C_3} &= \exists z_5, z_6.\ R(c_3, z_5) \wedge T(c_1, z_6, z_5)
  \end{align*}
  The decomposition after applying $\sigma_\mathrm{commit}$ is illustrated in \Cref{bcq-decomposition-example-figure}.
  \qed
\end{example}

Intuitively, the partial map $\sigma_\mathrm{commit}$ represents a partial commitment towards constructing the whole homomorphism. $\Commq{Q}{\sigma_\mathrm{commit}}$ is a collection of atoms which we expect to see in (the Datalog saturation of) the input instance, and for each $C$, $\Subq{Q}{\sigma_\mathrm{commit}}{C}$ is a query whose entailment tells us if $\sigma_\mathrm{commit}$ had been a good choice.

As the following lemma states, the original query is satisfied precisely when all split queries are.

\begin{lemma}[Base-connected query decomposition]
\label{bcq-base-connected-query-decomposition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a Boolean conjunctive query, $\mathcal{D}$ an instance and $\Sigma$ a finite set of single-headed GTGDs. Then $\mathcal{D} \cup \Sigma \models Q$ if and only if there exists a partial map $\sigma_\mathrm{partial}: \vec{z} \rightharpoonup \Terms(\mathcal{D}) \cup \Consts(\Sigma)$ such that
  \begin{itemize}
    \item $\mathcal{D} \cup \Sigma \models \Commq{Q}{\sigma_\mathrm{partial}}$
    \item $\mathcal{D} \cup \Sigma \models \Subq{Q}{\sigma_\mathrm{partial}}{C}$ for each $Q$-connected component $C$ of \newline $(\vec{z} \setminus\nobreak \mathrm{\dom{\sigma_\mathrm{partial}}})$.
  \end{itemize}
  \begin{proof}
    ($\Longrightarrow$): Suppose $\mathcal{D} \cup \Sigma \models Q$. Then by \Cref{sctree-soundness-completeness}, there exists a query homomorphism $\sigma: Q \rightarrow \Terms(\SCTree{\mathcal{D}}{\Sigma})$. Let $$B = \{ v \in \vec{z} \mid \sigma(v) \in \Terms(\mathcal{D}) \cup \Consts(\Sigma) \},$$ then $(\sigma \upharpoonright B)$ is a partial map satisfying conditions in the lemma.

    ($\Longleftarrow$): Suppose that $\sigma_\mathrm{partial}$ satisfies the two conditions, and let $C_1, \ldots, C_n$ be $Q$-connected components of $(\vec{z} \setminus\nobreak \mathrm{\dom{\sigma_\mathrm{partial}}})$. For each $1 \leq i \leq n$, we can take a query homomorphism $\sigma_{C_i}: \Subq{Q}{\sigma_\mathrm{partial}}{C_i} \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ by \Cref{sctree-soundness-completeness}. Since all of $\sigma_\mathrm{partial}, \sigma_{C_1}, \ldots, \sigma_{C_n}$ have disjoint domains, $\sigma = \sigma_\mathrm{partial} \cup \sigma_{C_1} \cup \ldots \cup \sigma_{C_n}$ is a function $\sigma: \vec{z} \rightarrow \Terms(\SCTree{\mathcal{D}}{\Sigma})$.
    
    Since every atom $A_j$ in $Q$ appears either in $\Commq{Q}{\sigma_\mathrm{partial}}$ or in precisely one $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$, $\sigma$ is a query homomorphism $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$, and therefore $\mathcal{D} \cup \Sigma \models Q$.
  \end{proof}
\end{lemma}

We can easily extend \Cref{bcq-base-connected-query-decomposition} to non-Boolean conjunctive queries.

\begin{corollary}
\label{base-connected-query-decomposition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query, $\mathcal{D}$ an instance and $\Sigma$ a finite set of single-headed GTGDs.
  
  Then for a substitution $\alpha: \FV(Q) \rightarrow \Terms(\mathcal{D})$, $\mathcal{D} \cup \Sigma \models \alpha(Q)$ if and only if there exists an extension $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D})$ of $\alpha$ satisfying conditions as in \Cref{bcq-base-connected-query-decomposition}.
\end{corollary}

% TODO: put a helpful diagram

In order to produce answers to the query using \Cref{base-connected-query-decomposition}, we need to decide whether or not $\mathcal{D} \cup \Sigma \models \Subq{Q}{\sigma_\mathrm{partial}}{C}$ holds. It turns out that we can exploit the connectedness of $\Subq{Q}{\sigma_\mathrm{partial}}{C}$ and the corecursive structure of $\SCTree{\mathcal{D}}{\Sigma}$ (\Cref{corecursiveness-of-sctree}) to check the query entailment recursively. To make this precise, we define the notion of a \emph{successful commit point}, a point at which a connected Boolean conjunctive query can be split in a way similar to \Cref{bcq-base-connected-query-decomposition}.

\begin{definition}
\label{successful-commit-point-definition}
  Let $Q$ be a connected Boolean conjunctive query and $\SCTree{\mathcal{D}}{\Sigma}$ a shortcutting chase tree. We say that a vertex $v \in \SCTree{\mathcal{D}}{\Sigma}$ with the associated bag $\mu(v)$ of facts is a \emph{successful commit point for $Q$ in $\SCTree{\mathcal{D}}{\Sigma}$} if there exists a $\Consts(\Sigma)$-free partial map $\sigma_\mathrm{commit}: \Vars(Q) \rightharpoonup \Terms(\mu(v)) \setminus \Consts(\Sigma)$, which we call a \emph{commit map at $v$}, such that
  \begin{itemize}
    \item $\dom{\sigma_\mathrm{commit}}$ is nonempty,
    \item $\mu(v) \models \Commq{Q}{\sigma_\mathrm{commit}}$, and
    \item for each $Q$-connected component $C$ of $(\Vars(Q) \setminus \dom{\sigma_\mathrm{commit}})$, there exists a $\Consts(\Sigma)$-free query homomorphism $\sigma_C: \Subq{Q}{\sigma_\mathrm{commit}}{C} \rightarrow \SCTree{\mu(v)}{\Sigma}$.
  \end{itemize}
  \qed
\end{definition}

To witness the entailment of a connected Boolean conjunctive query (with all query variables that get mapped to $\Consts(\Sigma)$ already substituted), finding a \emph{single} successful commit point in the shortcutting chase tree suffices.

\begin{theorem}(Recursive BCQ Entailment)
\label{recursive-connected-bcq-entailment}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a Boolean conjunctive query, $\mathcal{D}$ an instance and $\Sigma$ a finite set of single-headed GTGDs. Then there exists a $\Consts(\Sigma)$-free query homomorphism $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ if and only if there exists a successful commit point for $Q$ in $\SCTree{\mathcal{D}}{\Sigma}$.
  \begin{proof}
    ($\Longrightarrow$): Suppose that $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is a $\Consts(\Sigma)$-free query homomorphism. By \Cref{image-of-connected-variables-is-connected}, the set $T_{\Vars(Q)}$ of nodes in which terms in $\sigma(\Vars(Q))$ appear is a rooted tree in $\SCTree{\mathcal{D}}{\Sigma}$. Let $r$ be the root of $T_{\Vars(Q)}$ and $\mu(r)$ the bag of facts at $r$ in $\SCTree{\mathcal{D}}{\Sigma}$. We aim to show that $r$ is a successful commit point for $Q$.

    By \Cref{corecursiveness-of-sctree}, $T_{\Vars(Q)} = \SCTree{\mu(r)}{\Sigma}$. Since terms in $\sigma(\Vars(Q))$ only appear in $T_{\Vars(Q)}$, $\sigma$ is a $\Consts(\Sigma)$-free query homomorphism $\sigma: Q \rightarrow \SCTree{\mu(r)}{\Sigma}$. Let $B = \{ v \in \Vars(Q) \mid \sigma(v) \in \Terms(\mu(r)) \}$ be a nonempty set of variables mapped to terms in $r$ and define $\sigma_\mathrm{commit} = \sigma \upharpoonright B$, then $\sigma_\mathrm{commit}$ is a commit map at $r$.

    ($\Longleftarrow$): Suppose that $v$ is a successful commit point with a commit map $\sigma_\mathrm{commit}$. Let $C_1, \ldots, C_n$ be $Q$-connected components of $(\Vars(Q) \setminus \dom{\sigma_\mathrm{commit}})$. Then for each $1 \leq i \leq n$, there is a $\Consts(\Sigma)$-free query homomorphism $\sigma_{C_i}: \Subq{Q}{\sigma_\mathrm{commit}}{C_i} \rightarrow \SCTree{\mu(v)}{\Sigma}$. If we let $\sigma = \sigma_\mathrm{commit} \cup \sigma_{C_1} \cup \ldots \cup \sigma_{C_n}$, then we can check that $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ is a $\Consts(\Sigma)$-free query homomorphism as in the proof of \Cref{bcq-base-connected-query-decomposition}.
  \end{proof}
\end{theorem}

\begin{remark}
\label{remark-towards-query-answering-procedure}
  Notice that, to decide whether a vertex $v$ in $\SCTree{\mathcal{D}}{\Sigma}$ is a successful commit point for $Q$ with a commit map $\sigma_\mathrm{commit}$, we also need to decide if subqueries $\Subq{Q}{\sigma_\mathrm{commit}}{C_i}$ are satisfied in the subtree $\SCTree{\mu(v)}{\Sigma}$. As we require the commit map $\sigma_\mathrm{commit}$ to be a nonempty map, the number of bound variables in each subquery $\Subq{Q}{\sigma_\mathrm{commit}}{C_i}$ is strictly less than that of $Q$.

  Moreover, for Boolean conjunctive queries, the query entailment is unaffected by a certain renaming of constants in the root instance. Therefore, we only need to search for successful commit points up to renaming equivalence.
  \qed
\end{remark}

We capture the latter intuition with the following.

\begin{definition}
  Let $\mathcal{D}$ be an instance. A \emph{$\Sigma$-preserving renaming on $\mathcal{D}$} is an injective function $\sigma: \Terms(\mathcal{D}) \setminus \Consts(\Sigma) \xhookrightarrow{} T$ where $T$ is a set of terms with $T \cap \Consts(\Sigma) = \emptyset$.
\end{definition}

\begin{proposition}
\label{bcq-invariant-under-sigma-preserving-renaming}
  If $Q$ is a Boolean conjunctive query and $\sigma$ is $\Sigma$-preserving renaming on an instance $\mathcal{D}$, then $\mathcal{D} \cup \Sigma \models Q$ if and only if $\sigma(\mathcal{D}) \cup \Sigma \models Q$.
  \begin{proof}
    If we extend $\sigma$ to all of $\Terms(\SCTree{\mathcal{D}}{\Sigma})$ by defining $$\sigma'(t) =
    \begin{cases}
      \sigma(t) & \text{if } t \in \Consts(\mathcal{D}) \setminus \Consts(\Sigma) \\
      t & \text{otherwise}
    \end{cases}$$
    Then $\SCTree{\sigma'(\mathcal{D})}{\Sigma}$ is an isomorphic image of $\SCTree{\mathcal{D}}{\Sigma}$ under $\sigma'$. Now apply \Cref{sctree-soundness-completeness}.
  \end{proof}
\end{proposition}

\begin{remark}
  In \Cref{bcq-invariant-under-sigma-preserving-renaming}, we require that the renaming $\sigma$ \emph{preserves} all constants in $\Sigma$. This is because \begin{itemize}
    \item if $c \in \Consts(\Sigma)$ is renamed to some other constant by $\sigma$, then a rule in $\Sigma$ that fired in $\SCTree{\mathcal{D}}{\Sigma}$ may no longer fire in $\SCTree{\sigma(\mathcal{D})}{\Sigma}$ thereby invalidating the $(\Longrightarrow)$ implication, and
    \item if $t \in \Terms(\mathcal{D})$ is renamed to a constant in $\Sigma$, then a rule that did not fire in $\SCTree{\mathcal{D}}{\Sigma}$ may fire in $\SCTree{\sigma(\mathcal{D})}{\Sigma}$, invalidating $(\Longleftarrow)$ direction.
  \end{itemize}
\end{remark}

\begin{definition}
  We say that two instances $\mathcal{D}_1, \mathcal{D}_2$ are \emph{$\Sigma$-renaming-equivalent} (written $\mathcal{D}_1 \cong_\Sigma \mathcal{D}_2$) if there exists a $\Sigma$-preserving renaming $\sigma$ with $\sigma(\mathcal{D}_1) = \mathcal{D}_2$. It is easy to see that $\cong_\Sigma$ is an equivalence relation.
\end{definition}

\begin{proposition}
\label{renaming-equivalence-class-bound}
  For any shortcutting chase tree $\SCTree{\mathcal{D}}{\Sigma}$, there are only finitely many $\cong_\Sigma$-equivalence classes of bags in $\SCTree{\mathcal{D}}{\Sigma}$.
  \begin{proof}
    For any non-root node $v$ of $\SCTree{\mathcal{D}}{\Sigma}$, by \Cref{each-bag-in-sctree-is-k-sigma-small} there are at most $K + |\Consts(\Sigma)|$ terms present in the bag $\mu(v)$. Hence there are at most $|P| \cdot 2^{(K + |\Consts(\Sigma)|)}$ facts in $\mu(v)$, where $P$ is the set of predicates in $\mathcal{D} \cup \Sigma$. In particular, the number of $\cong_\Sigma$-equivalence classes in $\SCTree{\mathcal{D}}{\Sigma}$ is at most $2^{|P| \cdot 2^{(K + |\Consts(\Sigma)|)}} + 1$, where the bag at the root node accounts for $(+1)$.
  \end{proof}
\end{proposition}

We are ready to present a query-answering procedure \Cref{basic-query-answering-procedure} based on the intuition of \Cref{remark-towards-query-answering-procedure}. Note that, in $\textsc{EntailsConnectedBCQ}$, we can scan through all equivalence classes $[\mathcal{D}]_{\cong_\Sigma}$ of bags in $\SCTree{\mathcal{D}}{\Sigma}$ by a depth-first search, since
\begin{itemize}
  \item there are only finitely many such classes by \Cref{renaming-equivalence-class-bound}, and
  \item for each such $\cong_\Sigma$-equivalence class $\mathcal{E}$, there exists a path $v_1, \ldots, v_n$ from the root node of $\SCTree{\mathcal{D}}{\Sigma}$ such that
  \begin{enumerate}
    \item none of $\mu(v_1), \ldots, \mu(v_n)$ are $\cong_\Sigma$-equivalent
    \item $[\mu(v_n)]_{\cong_\Sigma} = \mathcal{E}$
  \end{enumerate}
  because we can always shorten a path not satisfying (1) by replacing a segment $v_i, \ldots, v_{i+m}$ such that $\mu(v_i) \cong_\Sigma \mu(v_{i+m})$ with just $v_i$, and then replacing all of $v_{i+m+1}, \ldots, v_n$ by their $\cong_\Sigma$-equivalent copies in the subtree rooted at $v_i$.
\end{itemize}

We will only use \Cref{basic-query-answering-procedure} as an intermediate step towards producing a rewriting. We will not go through the algorithm line by line, but we shall sketch the proof of its correctness and termination.

\begin{theorem}
  The procedure \textsc{AnswerConjunctiveQuery} in \Cref{basic-query-answering-procedure} produces all valid answers to \hyperref[GTGD-CQ-Answering]{GTGD-CQ Answering} in finite time.
  \begin{proof}[Proof (sketch)]
    Termination is clear since
    \begin{itemize}
      \item all \textbf{for}-loops iterate over a finite set, and
      \item size of connected BCQ decreases on every recursive call (\Cref{remark-towards-query-answering-procedure}).
    \end{itemize}

    We can first prove the correctness of \textsc{SatisfiedWith} for all connected BCQs by induction on the number of bound variables and recursively applying \Cref{recursive-connected-bcq-entailment}. It is then straightforward to see, by applying \Cref{base-connected-query-decomposition}, that \textsc{AnswerConjunctiveQuery} produces all valid answers.
  \end{proof}
\end{theorem}

\begin{algorithm}
\caption{Basic query answering procedure}
\label{basic-query-answering-procedure}
\begin{algorithmic}[1]
\State // decide if there exists a $\Consts(\Sigma)$-free query homomorphism
\State // $\sigma: Q \rightarrow \SCTree{\mathcal{D}}{\Sigma}$ for connected BCQ $Q$
\Procedure{EntailsConnectedBCQ}{$\mathcal{D}$, $\Sigma$, connected BCQ $Q$}
  \ForAll{equivalence class $[\mathcal{G}]_{\cong_\Sigma}$ of bags in $\SCTree{\mathcal{D}}{\Sigma}$}
    \If{\textsc{IsSuccessfulBranchingPoint}($\mathcal{G}$, $\Sigma$, $Q$)}
      \State \textbf{return true}
    \EndIf
  \EndFor
  \State \textbf{return false}
\EndProcedure
\State
\Procedure{IsSuccessfulBranchingPoint}{$\mathcal{D}$, $\Sigma$, connected BCQ $Q$}
  \ForAll{nonempty $\sigma_\mathrm{commit}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D}) \setminus \Consts(\Sigma)$}
    \If{\textsc{SatisfiedWith}($\mathcal{D}$, $\Sigma$, $Q$, $\sigma_\mathrm{commit}$)}
      \State \Return{\textbf{true}}
    \EndIf
  \EndFor
  \State \Return{\textbf{false}}
\EndProcedure
\State
\State // computes if the query is satisfied with a partial substitution $\sigma_\mathrm{partial}$
\Procedure{SatisfiedWith}{$\mathcal{D}$, $\Sigma$, $Q$, $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \Terms(\mathcal{D})$}
  \State \textbf{require} $\dom{\sigma_\mathrm{partial}} \supseteq \FV(Q)$
  \State $\mathcal{D}_\mathrm{Dsat} \gets \textsc{DatalogSaturate}(\ARew{\Sigma}, \mathcal{D})$
  \State $\mathrm{baseSatisfied} \gets \mathcal{D}_\mathrm{Dsat} \models \Commq{Q}{\sigma_\mathrm{partial}}$
  \State $C_1, \ldots, C_n \gets$ $Q$-connected components of $\Vars(Q) \setminus \dom{\sigma_\mathrm{partial}}$
  \State $\mathrm{allComponentsSatisfied} \gets \bigwedge_{i = 1}^n$
  \State \hskip1.5em \textsc{EntailsConnectedBCQ}($\mathcal{D}_\mathrm{Dsat}$, $\Sigma$, $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$)
  \State \Return{baseSatisfied \textbf{and} allComponentsSatisfied}
\EndProcedure
\State
\Procedure{AnswerConjunctiveQuery}{$\mathcal{D}$, $\Sigma$, conjunctive query $Q$}
  \ForAll{substitution $\alpha: \FV(Q) \rightarrow \Terms(\mathcal{D}) \cup \Consts(\Sigma)$}
    \ForAll{substitution $\sigma_{\Consts(\Sigma)}: (\Vars(Q) \setminus \FV(Q)) \rightharpoonup \Consts(\Sigma)$}
      \If{\textsc{SatisfiedWith}($\mathcal{D}$, $\Sigma$, $Q$, $\alpha \cup \sigma_{\Consts(\Sigma)}$)}
        \State \textbf{output} $\alpha$ as an answer
        \State \textbf{break} inner loop
      \EndIf
    \EndFor
  \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\newpage
\chapter{Deriving a Rewriting}\label{deriving-a-rewriting}

In \Cref{characterising-query-entailment-under-gtgds}, we developed \Cref{basic-query-answering-procedure} for producing all answers to a conjunctive query over single-headed GTGDs.

However, because of high data complexity, the algorithm is impractical for query-answering purposes: We have to explore a part of $\SCTree{\mathcal{D}}{\Sigma}$ for every single substitution $\alpha: \FV(Q) \rightarrow \Consts(\mathcal{D})$. So instead, we aim to use \Cref{basic-query-answering-procedure} as a stepping stone to devising a Datalog rewriting that works for arbitrary input $\mathcal{D}$.

The first important observation is that the entailment of a subquery in a proper subtree of $\SCTree{\mathcal{D}}{\Sigma}$ only depends on a tiny fraction of $\mathcal{D}$.

More precisely, suppose that a connected subquery $Q_\mathrm{sub}$ is satisfied in a subtree $T_c$ of $\SCTree{\mathcal{D}}{\Sigma}$ rooted at a non-root node $c$, and that $c$ is obtained by firing an existential rule $\tau = \forall \vec{x}.\ \beta \rightarrow \exists \vec{y}.\ H$ together with a substitution $\sigma: \vec{x} \rightarrow \Terms(\mathcal{D})$. Then there is a query homomorphism $Q_\mathrm{sub} \rightarrow T_c$ mapping all variables in $Q_\mathrm{sub}$ to nulls in $T_c$. If we let $\mathcal{D'}$ be a subset of $\mathcal{D}$ formed by extracting facts in $\mathcal{D}$ that are either
\begin{itemize}
  \item used in the substituted body $\sigma(\beta)$, or
  \item inherited by $c$, i.e. facts whose arguments are all in $\sigma(H)$,
\end{itemize}
then we can still fire $\tau$ with $\sigma$ in $\SCTree{\mathcal{D'}}{\Sigma}$ to obtain a node $c'$. As $c'$ inherits the same set of facts, the tree $T_c$ and the subtree $T_{c'}$ rooted at $c'$ are isomorphic, and in particular, there is a query homomorphism $Q_\mathrm{sub} \rightarrow T_{c'}$. As $\mathcal{D'}$ is guarded by $\sigma(\beta)$, $\mathcal{D'}$ is $(K, \Sigma)$-small. Ultimately, if we write $K$ for the maximum arity of predicates in $\Sigma \cup Q$, we only need a $(K, \Sigma)$-small set of facts to entail a subquery in a proper subtree.

Moreover, by \Cref{bcq-invariant-under-sigma-preserving-renaming}, we are only interested in the \emph{structure} of the $(K, \Sigma)$-small instance that is needed to satisfy a subquery. For example, suppose that we have found out that an instance $\{R(c_1, c_2), R(c_2, r_1)\}$ is sufficient to entail a subquery $\exists z.\ T(c_2, r_2, z)$, where only $r_1$ and $r_2$ are constants in $\Sigma$. We can replace $c_1$ and $c_2$ with any other constants and still obtain a valid implication such as $R(c_4, c_6) \wedge R(c_6, r_1) \rightarrow \exists z.\ T(c_6, r_2, z)$. By a generalisation, it is possible to deduce that $\forall x_1, x_2.\ R(x_1, x_2) \wedge R(x_2, r_1) \rightarrow \exists z.\ T(x_2, r_2, z)$ under $\Sigma$.

With these observations in mind, we adopt the following strategy for building a rewriting.

\begin{itemize}
  \item Start with an atomic rewriting $\ARew{\Sigma}$ of $\Sigma$.
  \item For each (\emph{not} necessarily maximal) $Q$-connected nonempty set $C$ of bound variables, introduce an intensional predicate $\mathrm{Subgoal}_C$, which asserts that a subquery induced by $C$ is satisfied by some partial substitution.
  \item For each \emph{local instance} $I$ (to be defined in \Cref{subquery-entailment-problem-section}), which represents a $(K, \Sigma)$-small structure in the base instance, decide if $I$ contains enough facts to entail a subquery $C$. If so, add a rule roughly of the form $I \rightarrow \mathrm{Subgoal}_C$.
  \item Finally, add all rules that \emph{integrate} subgoals into the goal atom. These rules essentially perform the inverse of \Cref{base-connected-query-decomposition} by gathering base facts and subgoal atoms together to infer the existence of a query homomorphism.
\end{itemize}

In \Cref{subquery-entailment-problem-section}, we define the precise structure of \emph{local instances}. We then briefly describe how to enumerate instances that entail a subquery in \Cref{section:naive-subquery-entailment-enumeration}, putting pieces together in \Cref{a-rewriting-algorithm} to present a rewriting algorithm. Finally, we discuss in \Cref{secomputation-optimisations} some optimisations on the naive algorithm presented in \Cref{section:naive-subquery-entailment-enumeration}.

\section{The Subquery Entailment Problem}
\label{subquery-entailment-problem-section}

To proceed with the strategy, we need to define a data structure that can be input to the following problem.

\begin{problem}[Informal]
\label{informal-subquery-entailment-problem}
  Suppose $I$ is a certain $(K, \Sigma)$-small structure, $C$ a $Q$-connected set of bound variables and $Q_{\mathrm{sub}, C}$ a subquery of $Q$ with existentials $C$. Does $I$ contain enough facts to entail $Q_{\mathrm{sub}, C}$?
\end{problem}

\subsection{Local Instances}
\label{subsection:local-instances}

First, we formalise the $(K, \Sigma)$-small structure.

Since there are at most $K$ (maximum arity of predicates in $\mathcal{D} \cup \Sigma$) non-$\Consts(\Sigma)$-terms in a $(K, \Sigma)$-small bag of facts, we might consider relabelling them with numbers $\{ 1, 2, \ldots, K \}$. However, if we completely identify bags with $\cong_\Sigma$-equivalence, we will no longer be able to recover the structure of $\SCTree{\mathcal{D}}{\Sigma}$. \Cref{sctree-simple-example-equivalence-classes} illustrates the issue with $\SCTree{\mathcal{D}}{\Sigma}$ from \Cref{sctree-simple-example}.

\begin{figure}[ht]
  \centering
  \includesvg{./diagrams/sctree-simple-example-bag-structures.drawio.svg}
  \caption{(Left) The shortcutting chase from \Cref{sctree-simple-example-diagram}. (Top right) If we identify bags with $\cong_\Sigma$ by relabelling terms with numbers, we get three bags representing $\cong_\Sigma$-equivalence classes. (Bottom right) We can no longer assemble these equivalence classes back to a chase structure since there is no way to distinguish between the inheritance and the introduction of terms in a chased node.}
  \label{sctree-simple-example-equivalence-classes}
\end{figure}

A trick to solve this issue is to use $2K$ labels, which we call \emph{local names}, with the convention that the same label in adjacent bags represents a term shared between them, as illustrated in \Cref{sctree-simple-example-local-names}. Formally, we work with the following structure.

\begin{figure}[ht]
  \centering
  \includesvg{./diagrams/sctree-simple-example-local-names.drawio.svg}
  \caption{(Left) The shortcutting chase from \Cref{sctree-simple-example-diagram}. (Right) relabelling of the shortcutting chase tree with local names. Two equal local names in sibling nodes (e.g. $2$ in $v'_2$ and $v'_3$) may represent different terms, while they represent the same term in parent-child nodes (e.g. $2$ in $v'_2$ and $v'_4$).}
  \label{sctree-simple-example-local-names}
\end{figure}

\begin{definition}
  A \emph{$(K, \Sigma)$-local instance} is a bag $I$ of facts such that
  \begin{itemize}
    \item for every fact $F \in I$, every term in $F$ is either
    \begin{itemize}
      \item a constant in $\Sigma$, or
      \item a \emph{local name} from the set $\{ 1, \ldots, 2K \}$ of constants not intersecting with $\Consts(\Sigma)$
    \end{itemize}
    \item there are at most $K$ local names active in $I$.
  \end{itemize}

  We write $\LNames{I}$ for the set of active local names in $I$.
  \qed
\end{definition}

Notice that, as shown in \Cref{sctree-simple-example-local-names}, we can translate a $\SCTree{\mathcal{D}}{\Sigma}$ into a chase-like structure that uses local names. By abuse of notation, we write $\SCTree{I}{\Sigma}$ for the chase-like structure obtained this way.

The structure $\SCTree{I}{\Sigma}$ can be constructed in a way similar to how we construct an ordinary shortcutting chase tree, except that when firing an existential rule, we \emph{reuse} a local name that was inactive at the parent node instead of introducing fresh nulls. For example, at $v'_4$ in \Cref{sctree-simple-example-local-names}, we are using a local name $3$, which is inactive at the parent node $v'_2$, in place of the null $n_4$. We no longer include the local name $1$ in $v'_4$ because $v'_4$ inherits no fact containing $1$. We say that such local names are \emph{dropped} by the chase step. If a local name $n$ dropped at $v$ becomes active again in a descendant $v'$ of $v$, then $n$ at $v$ and $v'$ represent different terms.

\subsection{Partially Substituted Subqueries}
\label{subsection:partially-substituted-subqueries}

Our next task is to represent a partially substituted subquery. Notice that, for a $Q$-connected set $C$ of variables, the subquery induced by $Q$ should
\begin{itemize}
  \item contain only atoms in $Q$ that mention a variable from $C$, and at the same time,
  \item have all variables not in $C$ substituted with a term.
\end{itemize}
It is convenient to introduce the following notion to describe the latter condition.

\begin{definition}
  For a conjunctive query $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ and a $Q$-connected subset $C$ of $\vec{z}$, the \emph{$Q$-boundary} (written $\partial_Q C$) of $C$ is the set of (either free or bound) variables in $Q$ defined by $$
    \partial_Q C = \left\{
      v \in \Vars(Q) \setminus C
        \;\middle|\;
      \begin{aligned}
        & \exists j \in J \text{ such that } \\
        & \Vars(A_j) \cap C \neq \emptyset \text{ and } v \in \Vars(A_j)
      \end{aligned}
    \right\}
  $$
  \qed
\end{definition}

\begin{example}
  Let
  \begin{align*}
    Q = \exists z_1,z_2,z_3,z_4,z_5,z_6.&\ S(z_1, z_2) \wedge S(z_1,z_3) \wedge R(z_2, z_3) \\
    &\wedge R(z_3, z_4) \wedge R(z_3, z_5) \wedge T(z_2, z_6, z_5)
  \end{align*}
  as in \Cref{query-connectedness-example}. Then $\partial_Q \{z_4\} = \{z_3\}$, $\partial_Q \{z_2\} = \{z_1, z_3, z_5, z_6\}$ and $\partial_Q \{z_5, z_6\} = \{z_2, z_3\}$. We illustrate the first example in \Cref{query-boundary-example}.
  \qed
\end{example}

\begin{figure}[h]
  \centering
  \includesvg{./diagrams/query-boundary-example.drawio.svg}
  \caption{For the query from \Cref{query-connectedness-example}, the $Q$-boundary $\partial_Q \{z_4\}$ of $\{z_4\}$ (red) is $\{z_3\}$ (blue).}
  \label{query-boundary-example}
\end{figure}

During a search for a successful commit point in $\SCTree{I}{\Sigma}$, a variable in $\partial_Q C$ is mapped either
\begin{itemize}
  \item to a constant in $\Consts(\Sigma)$, or
  \item to a local name in $I$.
\end{itemize}

With this observation, we are almost ready to define the notion of a partially substituted subquery. However, before we proceed, we remark on the following corner case regarding constants in the query.

Assume for a moment that there are no rule constants. Observe that, for a local instance $I$ to entail a subquery $\exists y.\ T(1, y, c)$ containing a constant $c$, there must be some fact in $I$ that contains $c$ since otherwise $c$ is never introduced to the shortcutting chase tree.

This remark motivates the following definition.

\begin{definition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query, $C$ be a $Q$-connected subset of bound variables in $Q$ and $I$ a $(K, \Sigma)$-local instance. An \emph{embedding of constants adjacent to $C$ into $I$} is an injective map $\iota: S_{Q, C} \hookrightarrow \LNames{I}$, where $S_{Q, C}$ is the set of constants in the subquery defined by $$
  S_{Q, C} = \left\{
      c \in \Consts(Q) \setminus \Consts(\Sigma)
        \;\middle|\;
      \begin{aligned}
        & \exists j \in J \text{ such that } \\
        & \Vars(A_j) \cap C \neq \emptyset \text{ and } c \in \Consts(A_j)
      \end{aligned}
    \right\}.
  $$
\end{definition}

Putting these concepts together, we obtain the following notion of a subquery.

\begin{definition}
  Let $Q$ be a conjunctive query, $C$ be a $Q$-connected subset of bound variables in $Q$ and $I$ a $(K, \Sigma)$-local instance. A \emph{representation of a subquery of $Q$ induced by $C$ and local to $I$} is a triple $(\sigma_{\Consts(\Sigma)}, \sigma_I, \iota)$ of mappings
  \[\begin{array}{rccl}
    \sigma_{\Consts(\Sigma)}: & \partial_Q C &\rightharpoonup& \Consts(\Sigma) \\
    \sigma_I: & \partial_Q C &\rightharpoonup& \LNames{I} \\
    \iota: & S_{Q,C} &\hookrightarrow& \LNames{I}
  \end{array}\]
  such that \begin{itemize}
    \item $\{ \dom{\sigma_{\Consts(\Sigma)}}, \dom{\sigma_I} \}$ is a partition of $\partial_Q C$, and
    \item $\iota$ is an embedding of constants adjacent to $C$ into $I$.
  \end{itemize}

  Given such a triple, its \emph{local realisation at $I$}, written $\LRealz{Q}{\sigma_{\Consts(\Sigma)}, \sigma_I, \iota}$, is the connected Boolean conjunctive query $$
  \LRealz{Q}{\sigma_{\Consts(\Sigma)}, \sigma_I, \iota} = \exists \vec{C}. \bigwedge_{j \in J_C} (\sigma_{\Consts(\Sigma)} \cup \sigma_I \cup \iota)(A_j)
  $$
  mentioning local names, where $J_C = \{ j \in J \mid \Vars(A_j) \cap C \neq \emptyset \}$.

  \qed
\end{definition}

\begin{example}
\label{local-realisation-of-subquery-representation}
  Let
  $$
    Q = \exists z_1,z_2,z_3,z_4.\ S(c_1, z_1, z_4, z_2) \wedge T(z_1, c_2, z_3) \wedge T(z_3, c_1, z_4),
  $$
  where $c_1, c_2$ are constants not in $\Sigma$, $C = \{z_1, z_2\}$ and $$I = \{ S(1, 2, 3, 4), T(4, 2, 1), R(2, 3) \}.$$
  Then $\partial_Q C = \{ z_3, z_4 \}$ and $S_{Q,C} = \{c_1, c_2\}$. If we let
  \[\begin{array}{rcl}
    \sigma_{\Consts(\Sigma)} &=& \{ z_3 \mapsto r_1 \} \\
    \sigma_I &=& \{ z_4 \mapsto 2 \} \\
    \iota &=& \{ c_1 \mapsto 1, c_2 \mapsto 3 \}
  \end{array}\]
  where $r_1 \in \Consts(\Sigma)$, then $$
  \LRealz{Q}{\sigma_{\Consts(\Sigma)}, \sigma_I, \iota} = \exists z_1, z_2.\ S(1, z_1, 2, z_2) \wedge T(z_1, 3, r_1).
  $$
  \qed
\end{example}

\subsection{Formalizing the Subquery Entailment Problem}

Combining notions defined in \Cref{subsection:local-instances} and \Cref{subsection:partially-substituted-subqueries}, we can formally re-define the \Cref{informal-subquery-entailment-problem}.

\begin{definition}
  Let $Q = \exists \vec{z}. \bigwedge_{j \in J} A_j$ be a conjunctive query. A \emph{$Q$-subquery entailment problem instance} is a 5-tuple $(C, I, \sigma_{\Consts(\Sigma)}, \sigma_I, \iota)$ where
  \begin{itemize}
    \item $C$ is a $Q$-connected set of variables bound in $Q$
    \item $I$ is a $(K, \Sigma)$-local instance
    \item $(\sigma_{\Consts(\Sigma)}, \sigma_I, \iota)$ is a representation of a subquery of $Q$ induced by $C$ and local to $I$
  \end{itemize}
\end{definition}

\begin{problem}[Subquery Entailment Problem, formalisation of \Cref{informal-subquery-entailment-problem}]
\label{subquery-entailment-problem}
  Given a $Q$-subquery entailment problem instance $\mathcal{I} = (C, I, \sigma_{\Consts(\Sigma)}, \sigma_I, \iota)$, does $I \cup \Sigma \models \LRealz{Q}{\sigma_{\Consts(\Sigma)}, \sigma_I, \iota}$ hold?
  \qed
\end{problem}

\section{The Naive Subquery Entailment Enumeration}
\label{section:naive-subquery-entailment-enumeration}

We can solve \Cref{subquery-entailment-problem} with only a minor modification to \Cref{basic-query-answering-procedure}, with the basic idea being that we descend the $\SCTree{I}{\Sigma}$ to search for a successful commit point. The only difference is that when we fire an existential rule, we must not drop local names that appear in the substituted query $Q_\mathrm{subst}$, since otherwise $Q_\mathrm{subst}$ becomes immediately unsatisfiable in the chased subtree. The first version of our algorithm (\Cref{naive-subquery-entailment-enumeration}) is, therefore, a verbatim translation of \Cref{basic-query-answering-procedure} into the context of local instances.

Later in \Cref{secomputation-optimisations}, we discuss optimisations of \Cref{naive-subquery-entailment-enumeration}. Nevertheless, for now, we proceed to the other components of the rewriting algorithm to see how outputs from \Cref{naive-subquery-entailment-enumeration} assemble into a Datalog rewriting.

\begin{algorithm}
\caption{Naive Subquery Entailment Enumeration}
\label{naive-subquery-entailment-enumeration}
\begin{algorithmic}[1]
\State // decide if there exists a $\Consts(\Sigma)$-free query homomorphism
\State // $\sigma: Q \rightarrow \SCTree{I}{\Sigma}$ for a BCQ $Q$ with only
\State // $\LNames{I}$ as query constants
\Procedure{EntailsConnectedBCQ}{$I$, $N$, $\Sigma$, connected BCQ $Q$}
  \ForAll{local instance $I'$ in $\SCTree{I}{\Sigma}$ that can be reached\par
  without dropping local names $\LNames{I} \cap \Consts(Q)$}
    \If{\textsc{IsSuccessfulBranchingPoint}($I$, $\Sigma$, $Q$)}
      \State \textbf{return true}
    \EndIf
  \EndFor
  \State \textbf{return false}
\EndProcedure
\State
\Procedure{IsSuccessfulBranchingPoint}{$I$, $\Sigma$, connected BCQ $Q$}
  \ForAll{nonempty $\sigma_\mathrm{commit}: \Vars(Q) \rightharpoonup \LNames{I}$}
    \If{\textsc{BooleanQSatisfiedWith}($I$, $\Sigma$, $Q$, $\sigma_\mathrm{commit}$)}
      \State \Return{\textbf{true}}
    \EndIf
  \EndFor
  \State \Return{\textbf{false}}
\EndProcedure
\State
\State // computes if Boolean $Q$ that only has $\LNames{I}$ as query constants
\State // is satisfied with a partial substitution $\sigma_\mathrm{partial}: \Vars(Q) \rightharpoonup \LNames{I}$
\Procedure{BCQSatisfiedWith}{$I$, $\Sigma$, $Q$, $\sigma_\mathrm{partial}$}
  \State $I_\mathrm{Dsat} \gets \textsc{DatalogSaturate}(\ARew{\Sigma}, I)$
  \State $\mathrm{baseSatisfied} \gets I_\mathrm{Dsat} \models \Commq{Q}{\sigma_\mathrm{partial}}$
  \State $C_1, \ldots, C_n \gets$ $Q$-connected components of $\Vars(Q) \setminus \dom{\sigma_\mathrm{partial}}$
  \State $\mathrm{allComponentsSatisfied} \gets \bigwedge_{i = 1}^n$
  \State \hskip1.5em \textsc{EntailsConnectedBCQ}($I_\mathrm{Dsat}$, $\Sigma$, $\Subq{Q}{\sigma_\mathrm{partial}}{C_i}$)
  \State \Return{baseSatisfied \textbf{and} allComponentsSatisfied}
\EndProcedure
\State
\Procedure{EnumerateSubqueryEntailments}{\par
  finite set $\Sigma$ of single-headed GTGDs, conjunctive query $Q$}
  \ForAll{$Q$-subquery entailment instance $\mathcal{I} = (C, I, \sigma_{\Consts(\Sigma)}, \sigma_I, \iota)$}
    \If{\textsc{EntailsConnectedBCQ}($I$, $\Sigma$, $\LRealz{Q}{\sigma_{\Consts(\Sigma)}, \sigma_I, \iota}$)}
      \State \textbf{output} $\mathcal{I}$
    \EndIf
  \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{A Rewriting Algorithm}
\label{a-rewriting-algorithm}

\subsection{From a Subquery Entailment to a Datalog Rule}
\label{subquery-entailment-to-datalog-rule}

Now that we can enumerate subquery entailments, we show how to turn them into Datalog rules that derive subgoals.

Suppose that $C$ is a $Q$-connected set of bound variables in $Q$, and let $Q_\mathrm{sub}$ be the (unsubstituted) subquery induced by $C$. The way in which $Q_\mathrm{sub}$ is satisfied can be fully described by how variables in $\partial_Q C$ are mapped to terms. Therefore, to represent a subquery satisfaction, we introduce the \emph{subgoal predicate} as an intensional predicate $\mathrm{Subgoal}_{Q, C}$ having the arity $|\partial_Q C|$.

For each \textsc{yes} instance of \Cref{subquery-entailment-problem}, we wish to add a Datalog rule (which we will write $\mathrm{SubgoalRule}(\mathcal{I})$) that has the local instance in the body and the subgoal atom as the head.
For example, suppose that the subquery in \Cref{local-realisation-of-subquery-representation} is entailed by the local instance $I$ given in the example. We would then like to add a rule $$
  \forall x_2, x_4.\ S(c_1, x_2, c_2, x_4) \wedge T(x_4, x_2, c_1) \wedge R(x_2, c_2) \rightarrow \mathrm{Subgoal}_{Q, \{z_1, z_2\}}(r_1, x_2)
$$
where $x_4$ is the variable replacing $z_4$ in the original query.

Formally, we define $\mathrm{SubgoalRule}(\mathcal{I})$ as follows.

\begin{definition}
  Let $\mathcal{I} = (C, I, \sigma_{\Consts(\Sigma)}, \sigma_I, \iota)$ be a $Q$-subquery entailment problem instance. Let $S$ be the subgoal atom substituted with local names, defined by $$
    S = (\sigma_{\Consts(\Sigma)} \cup \sigma_I)\left(\mathrm{Subgoal}_{Q, C}\left(\overrightarrow{\partial_Q C}\right)\right).
  $$

  Let $\rho$ be a renaming of all local names to variables and query constants, defined by $$
    \rho(n) = \begin{cases}
      \iota^{-1}(n) & \text{if } n \in \range{\iota} \\
      x_n & \text{otherwise}
    \end{cases}
  $$

  Finally, let $\mathrm{SubgoalRule}(\mathcal{I})$ be the Datalog rule given by $$
    \mathrm{SubgoalRule}(\mathcal{I}) = \rho\left(I \rightarrow S\right)
  $$ with all free variables universally quantified.
  \qed
\end{definition}

Under the identification of the subgoal atom $\mathrm{Subgoal}_{Q, C}(\vec{t})$ with the subquery $\Subq{Q}{\left\{ \overrightarrow{\partial_Q C} \mapsto \vec{t} \right\}}{C}$ of $Q$, the rule $\mathrm{SubgoalRule}(\mathcal{I})$ is sound if and only if $\mathcal{I}$ is an \textsc{yes} instance of \Cref{subquery-entailment-problem}.

\subsection{Glueing Subgoals}
\label{glueing-subgoals}

As a final step in the Datalog rewriting algorithm, we need to generate rules that combine subgoals to derive the final goal. To this end, we introduce the \emph{goal atom} $\mathrm{Goal}\left( \overrightarrow{\FV(Q)} \right)$ having $\FV(Q)$ as arguments.

Recall that a subgoal atom $\mathrm{Subgoal}_{Q, C}(\vec{t})$ indicates that the set $C$ of bound variables are witnessed existentially with a partial substitution $\left\{ \overrightarrow{\partial_Q C} \mapsto \vec{t} \right\}$ to the boundary of $C$. For a set $\mathrm{BVars} \supseteq \FV(Q)$ of variables to be witnessed at the base, the following rule is sound by \Cref{base-connected-query-decomposition}.

\begin{definition}
\label{subgoal-glueing-rule}
  For a set $\mathrm{BVars} \subseteq \FV(Q)$, define the \emph{subgoal glueing rule} $\mathrm{SglGlueingRule}_\mathrm{BVars}$ by
  $$
    \mathrm{SglGlueingRule}_\mathrm{BVars} = (TODO)
  $$
\end{definition}

\subsection{Putting Pieces Together}

Finally, we combine components from \Cref{section:naive-subquery-entailment-enumeration}, \Cref{subquery-entailment-to-datalog-rule} and \Cref{glueing-subgoals}. The following algorithm produces a Datalog rewriting of a GTGD-CQ pair.

(TODO)

\section{Optimising the Subquery Entailment Enumeration}
\label{secomputation-optimisations}

% TODO: Write about "memoisation", use of DFS and re-normalisation of local instances to {0, ..., K-1}.

\newpage
\chapter{Implementation, Testing and Evaluation}

% TODO: talk about the implementation architecture (how the rewriting system makes a single call to an implementation of "SubqueryEntailmentComputation", and how the CLI implementation subsumes the rules before presenting the output to the user) and briefly indicate how the user can try running the rewrite algorithm using the fat jar

% TODO: talk about test queries with "contractible" hypergraph structures 

% TODO: include example performance for some test queries (with three implementations of SEComputation), with some simple calculation on the size of Subquery Entailment Problem space we need to solve for each test case

\newpage
\chapter{Conclusions and Further Discussion}

\section{Conclusions}

\section{Future Work}

% TODO: talk about search space pruning with an example
% TODO: talk about how we do not really need to solve subquery entailment problem for most queries (ones that are "contractible"), and the possibility of exploiting the acyclicity in the middle of SE computation
% TODO: talk about integrating an optimised datalog saturation engine
% TODO: talk about "strict existential subquery entailments" for minimising the output rule size

\printbibliography

\end{document}
