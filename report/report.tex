\documentclass[12pt]{article}

\usepackage[a4paper, margin=1.3in]{geometry}
\usepackage{biblatex}
\usepackage{setspace}
\usepackage{amstext}

\addbibresource{references.bib}

\title{Querying Infinite GTGD Chases}
\author{Ryosuke Kondo}
\date{May 2023}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

\section*{Abstract}

\newpage
\section{Introduction}

\subsection{Background}

Consider the following situation: (TODO; Think about some OMQA instance where two independent parties provide a data over which we would like to perform an existential join query.)

We would now like to find out (TODO; insert here the query content in English). This amounts to finding all \emph{answers} to a first-order existential sentence (TODO; insert here the query in first-order language), where each answer is a \emph{substitution} mapping free variables (TODO) to constants in data sources that make the sentence true.

Unlike querying a single relational database, it is not sufficient to perform a non-existential join query (TODO; insert here the query with existentials stripped away) and project the resulting tuples to ignore uninteresting components. Even though no constant in the input database matches variables in the partially-applied query (TODO; insert here a partially-applied query), we can deduce from the constraints that there must be some \emph{unknown} values that matches (TODO; insert here a partially-applied query).

In general, the problem of answering queries given (1) a collection of \emph{incomplete} data sources, (2) a finite set of \emph{data integration rules} that can derive the existence of new tuples and (3) a conjunctive query (CQ) is called Ontology-Mediated Query Answering (OMQA) (TODO: cite https://www.ijcai.org/Proceedings/16/Papers/600.pdf).

Data integration rules in OMQA problem instances are often written as Tuple-Generating Dependencies (TGDs), which are first-order sentences of the form $\forall \vec{x}. \Phi(\vec{x}, \vec{c}) \rightarrow \exists \vec{y}. \Psi(\vec{x}, \vec{y}, \vec{c}')$. In the example above, for instance, the rules can be translated into logical formulae (TODO: translate the rules into TGDs). Formulated this way, we can think of OMQA problems as finding all assignments $\sigma$ of free variables in the input query that validate the logical entailment relation $\mathcal{D} \land \Sigma \models \sigma(Q)$, where $\mathcal{D}$ is the conjunction of all records present in data sources, $\Sigma$ is the data integration rules and $Q$ is the input CQ.

Unfortunately, however, OMQA problems with general TGDs turned out to be undecidable (TODO: cite? https://arxiv.org/abs/1212.3357 can be cited here, but their result is more of "essentiality of guardedness" so there should be a more appropriate literature to cite). In response to this, (TODO: cite https://arxiv.org/abs/1212.3357) identified \emph{Guarded TGDs} (GTGDs) as a subclass of TGDs that is expressive enough to contain several classes of description logics, yet leaves OMQA problems decidable.

\subsection{Previous Works}

Despite OMQA problems over GTGDs being known to be decidable for several years, only a small number of work have been done to develop computationally tractable algorithms for these problems. A recent work by (TODO: cite https://arxiv.org/abs/1911.03679) suggested that we can efficiently rewrite a set of GTGD rules into a so-called \emph{Datalog saturation} of it, which is a set of existential-free TGDs that is "equivalent" to the original rule set for existential-free queries. The rewriting algorithm has been improved, implemented and evaluated in (TODO: cite https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf). 

(TODO: include a diagram indicating the scheme of how Datalog saturation is incorporated into OMQA)

Even though the implementation by (TODO: cite https://krr-oxford.github.io/Guarded-saturation/files/p2537-benedikt-long.pdf) only supports atomic queries out-of-the-box, we can reduce any \emph{acyclic} existential queries into a few guarded rules and a single goal atom containing just the free variables in the original query. For the (TODO: reference to the example given at the beginning of Section 1.1) query, we can add a (TODO)-ary goal predicate $\mathrm{Goal}(-, -)$ and rules (TODO: apply the reduction). However, such reduction does not apply to cyclic queries (e.g. a \emph{triangle query} $\exists x,y,z. R(w, x, y) \land S(y, z) \land S(z, x)$) in general.

(TODO: The following two paragraphs clearly do not fit here, but I think they should be present in the introduction, or else the exact problem I worked on is very difficult to communicate. Reorganize?)

It has been known that the entailment $\mathcal{D} \land \Sigma \models \sigma(Q)$ holds if and only if $\sigma(Q)$ is witnessed by the \emph{chase} of $\mathcal{D}$, which, informally speaking, is the result of \emph{repairing} $\mathcal{D}$ by generating tuples using rules in $\Sigma$ infinitely many times. % citation needed

Moreover, it has also been known that there exists a \emph{Datalog rewriting} of a finite set of GTGD rules and an arbitrary CQ (TODO: cite "Rewriting Guarded Negation Queries" by Vince B\'ar\'any et al.). We will refer the problem of finding a Datalog rewriting of a GTGD rule set and a CQ by \emph{GTGD-Datalog Rewriting}. Note that Datalog-saturating a GTGD rule set is a special case of GTGD-Datalog Rewriting problem where the query is always atomic.

\emph{To the best of my knowledge, however, no work has implemented a query answering procedure for generic CQs under GTGDs}. Given that many real-world database queries are cyclic (TODO: evidence?), limiting ourselves to acyclic existential queries may pose issues on smooth adoptation of OMQA systems.

\subsection{Contribution of This Work}

The contribution of this work is threefold:

\begin{itemize}
  \item By examining the structure of chases, I derived a novel reduction of GTGD-Datalog Rewriting problem into exponentially many small instances of GTGD query answering problems with \emph{boolean} CQs (BCQs), which no longer have free variables.
  \item By making use of properties of chases, I demonstrate how BCQ answering over GTGD rules can be decided using a simple product of two \emph{tree automata}. By eliminating redundant nondeterminism in these automata, I derived a novel recursive procedure for deciding BCQ entailment problems, which can be memoized to further speed up subsequent BCQ answerings.
  \item Last but not least, I provide a Java implementation of the former two algorithms which, when combined, can be assembled into an OMQA system.
\end{itemize}

\subsection{Outline of This Report}

(TODO: use in-doc links)

In Chapter 2, I introduce basic terminologies and results that will be used throughout the report.

In Chapter 3, I revisit the notion of "tree-like chase proof" and introduce the notion of "shortcut chases" (TODO: I'm pretty sure this have been defined elsewhere; find a literature if possible and cite here?) with a few diagrams. I then provide a simple analysis of how answers of the input query must be embedded into the chase tree, and argue that for rewriting purpose it is sufficient to decide whether a given rule plus a guarded set is "large enough" to entail a boolean conjunctive subquery of a particular form.

In Chapter 4, I begin with introducing nondeterministic finitely-branching-tree automata. We then discuss the most natural way to decide BCQ entailment using a formal product of "wildly nondeterministic branching query automaton" and "naive chase automaton". I show that, by carefully balancing the role of these two automata, we can make the chase automaton deterministic, and argue that we can translate the so-obtained automaton into a recursive decision algorithm.

In Chapter 5, we discuss the details of implementation and its verification. I provide some benchmarks to observe how the algorithm runtime increases as the input becomes larger.

We conclude the report with an overview, and discuss some weakness of the algorithm which may be improved in future studies.

\newpage
\section{Preliminaries}

\newpage
\section{Chase-Trees}

\newpage
\section{Deriving a Decision Procedure}

\newpage
\section{Implementation, Verification and Evaluation}

\newpage
\section{Conclusion}

\printbibliography

\end{document}
