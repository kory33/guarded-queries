@inproceedings{bienvenu16,
  author    = {Bienvenu, M.},
  title     = {Ontology-Mediated Query Answering: Harnessing Knowledge to Get More from Data},
  year      = {2016},
  isbn      = {9781577357704},
  publisher = {AAAI Press},
  abstract  = {Ontology-mediated query answering (OMQA) is a new paradigm in data management that seeks to exploit the semantic knowledge expressed in ontologies to improve query answering over data. This paper briefly introduces OMQA and gives an overview of two recent lines of research.},
  booktitle = {Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence},
  pages     = {4058–4061},
  numpages  = {4},
  location  = {New York, New York, USA},
  series    = {IJCAI'16}
}

 @article{cali_gottlob_kifer_2013,
  title   = {Taming the infinite chase: Query answering under expressive relational constraints},
  volume  = {48},
  DOI     = {10.1613/jair.3873},
  journal = {Journal of Artificial Intelligence Research},
  author  = {Calì, A. and Gottlob, G. and Kifer, M.},
  year    = {2013},
  pages   = {115–174}
}

@InProceedings{beeri_vardi_1981,
  author    = {Beeri, C. and Vardi, M. Y.},
  editor    = {Even, Shimon and Kariv, Oded},
  title     = {The implication problem for data dependencies},
  booktitle = {Automata, Languages and Programming},
  year      = {1981},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {73--85},
  abstract  = {In this paper we study the implication and the finite implication problems for data dependencies. When all dependencies are total the problems are equivalent and solvable but are NP-hard, i.e., probably computationally intractable. For non-total dependencies the implication problem is unsolvable, and the finite implication problem is not even partially solvable. Thus, there can be no formal system for finite implication. The meta decision problems of deciding for a given class of dependencies whether the implication problem is solvable or whether implication is equivalent to finite implication are also unsolvable.},
  isbn      = {978-3-540-38745-9}
}

@online{kappelmann_2019,
  author       = {Kappelmann, K.},
  title        = {Decision Procedures for Guarded Logics},
  date         = {2019-11-09},
  version      = 2,
  langid       = {english},
  eprinttype   = {arxiv},
  eprint       = {1911.03679v2},
  doi          = {https://doi.org/10.48550/arXiv.1911.03679}
}

 @article{benedikt_buron_germano_kappelmann_motik_2022,
  title   = {Rewriting the infinite chase},
  volume  = {15},
  DOI     = {10.14778/3551793.3551851},
  number  = {11},
  journal = {Proceedings of the VLDB Endowment},
  author  = {Benedikt, M. and Buron, M. and Germano, S. and Kappelmann, K. and Motik, B.},
  year    = {2022},
  month   = {7},
  pages   = {3045–3057}
}

@InProceedings{barany_benedikt_cate_2013,
  author    = {B{\'a}r{\'a}ny, Vince and Benedikt, Michael and ten Cate, Balder},
  editor    = {Chatterjee, Krishnendu and Sgall, Jir{\'i}},
  title     = {Rewriting Guarded Negation Queries},
  booktitle = {Mathematical Foundations of Computer Science 2013},
  year      = {2013},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {98--110},
  abstract  = {The Guarded Negation Fragment (GNFO) is a fragment of first-order logic that contains all unions of conjunctive queries, a restricted form of negation that suffices for expressing some common uses of negation in SQL queries, and a large class of integrity constraints. At the same time, as was recently shown, the syntax of GNFO is restrictive enough so that static analysis problems such as query containment are still decidable. This suggests that, in spite of its expressive power, GNFO queries are amenable to novel optimizations. In this paper we provide further evidence for this, establishing that GNFO queries have distinctive features with respect to rewriting. Our results include effective preservation theorems for GNFO, Craig Interpolation and Beth Definability results, and the ability to express the certain answers of queries with respect to GNFO constraints within very restricted logics.},
  isbn      = {978-3-642-40313-2}
}

@inproceedings{bancilhon_ramakrishnan_1986,
  author = {Bancilhon, Francois and Ramakrishnan, Raghu},
  title = {An Amateur's Introduction to Recursive Query Processing Strategies},
  year = {1986},
  isbn = {0897911911},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/16894.16859},
  doi = {10.1145/16894.16859},
  abstract = {This paper surveys and compares various strategies for processing logic queries in relational databases. The survey and comparison is limited to the case of Horn Clauses with evaluable predicates but without function symbols. The paper is organized in three parts. In the first part, we introduce the main concepts and definitions. In the second, we describe the various strategies. For each strategy, we give its main characteristics, its application range and a detailed description. We also give an example of a query evaluation. The third part of the paper compares the strategies on performance grounds. We first present a set of sample rules and queries which are used for the performance comparisons, and then we characterize the data. Finally, we give an analytical solution for each query/rule system. Cost curves are plotted for specific configurations of the data.},
  booktitle = {Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data},
  pages = {16–52},
  numpages = {37},
  location = {Washington, D.C., USA},
  series = {SIGMOD '86}
}

@article{fagin_kolaitis_miller_popa_2005,
  title = {Data exchange: semantics and query answering},
  journal = {Theoretical Computer Science},
  volume = {336},
  number = {1},
  pages = {89-124},
  year = {2005},
  note = {Database Theory},
  issn = {0304-3975},
  doi = {https://doi.org/10.1016/j.tcs.2004.10.033},
  url = {https://www.sciencedirect.com/science/article/pii/S030439750400725X},
  author = {Ronald Fagin and Phokion G. Kolaitis and Renée J. Miller and Lucian Popa},
  keywords = {Data exchange, Data integration, Dependencies, Universal solution, Chase, Query answering, Certain answers, Computational complexity, First-order inexpressibility},
  abstract = {Data exchange is the problem of taking data structured under a source schema and creating an instance of a target schema that reflects the source data as accurately as possible. In this paper, we address foundational and algorithmic issues related to the semantics of data exchange and to the query answering problem in the context of data exchange. These issues arise because, given a source instance, there may be many target instances that satisfy the constraints of the data exchange problem. We give an algebraic specification that selects, among all solutions to the data exchange problem, a special class of solutions that we call universal. We show that a universal solution has no more and no less data than required for data exchange and that it represents the entire space of possible solutions. We then identify fairly general, yet practical, conditions that guarantee the existence of a universal solution and yield algorithms to compute a canonical universal solution efficiently. We adopt the notion of the “certain answers” in indefinite databases for the semantics for query answering in data exchange. We investigate the computational complexity of computing the certain answers in this context and also address other algorithmic issues that arise in data exchange. In particular, we study the problem of computing the certain answers of target queries by simply evaluating them on a canonical universal solution, and we explore the boundary of what queries can and cannot be answered this way, in a data exchange setting.}
}

@software{Benedikt_Rewriting_the_Infinite,
  author = {Benedikt, Michael and Buron, Maxime and Germano, Stefano and Kappelmann, Kevin and Motik, Boris},
  title = {{Rewriting the Infinite Chase}},
  url = {https://github.com/KRR-Oxford/Guarded-saturation},
  version = {1.0.0}
}

@article{dantsin_eiter_gottlob_voronkov_2001,
  author = {Dantsin, Evgeny and Eiter, Thomas and Gottlob, Georg and Voronkov, Andrei},
  title = {Complexity and Expressive Power of Logic Programming},
  year = {2001},
  issue_date = {September 2001},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {33},
  number = {3},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/502807.502810},
  doi = {10.1145/502807.502810},
  abstract = {This article surveys various complexity and expressiveness results on different forms of logic programming. The main focus is on decidable forms of logic programming, in particular, propositional logic programming and datalog, but we also mention general logic programming with function symbols. Next to classical results on plain logic programming (pure Horn clause programs), more recent results on various important extensions of logic programming are surveyed. These include logic programming with different forms of negation, disjunctive logic programming, logic programming with equality, and constraint logic programming.},
  journal = {ACM Comput. Surv.},
  month = {sep},
  pages = {374–425},
  numpages = {52},
  keywords = {nonmonotonic logic, logic programming, expressive power, datalog, Complexity, query languages}
}

@website{scalacheck,
  author={Nilsson, Rickard}, 
  title={ScalaCheck: Property-based testing for scala},
  howpublished = {\url{https://scalacheck.org/}},
  note         = {Accessed: 2023-05-14},
  year={2021}
  }

@website{junit,
  author={The JUnit Team}, 
  title={JUnit 5},
  howpublished = {\url{https://junit.org/junit5/}},
  note         = {Accessed: 2023-05-14},
  year={2023}
  }
