package io.github.kory33.guardedqueries.core.rewriting

import io.github.kory33.guardedqueries.core.utils.CachingFunction
import io.github.kory33.guardedqueries.core.utils.extensions.ConjunctiveQueryExtensions.given
import io.github.kory33.guardedqueries.core.utils.extensions.VariableSetExtensions.given
import uk.ac.ox.cs.pdq.fol._

import java.util.concurrent.atomic.AtomicInteger

/**
 * A mapping that sends a set V of connected variables to an atom that asserts that the query
 * has been existentially satisfied for the variables in V with a particular instantiation of
 * the neighborhood of V.
 */
class SubgoalAtomGenerator(
  boundVariableConnectedQuery: ConjunctiveQuery,
  intentionalPredicatePrefix: String
) {
  private val connectedComponents =
    CQBoundVariableConnectedComponents(boundVariableConnectedQuery)

  if (connectedComponents.maximallyConnectedSubqueries.size > 1)
    throw new IllegalArgumentException(
      s"The given query ($boundVariableConnectedQuery) is not bound-variable-connected."
    )

  if (connectedComponents.boundVariableFreeAtoms.nonEmpty)
    throw new IllegalArgumentException(
      s"The given query ($boundVariableConnectedQuery) contains bound-variable-free atoms."
    )

  private val queryBoundVariables: Set[Variable] =
    boundVariableConnectedQuery.getBoundVariables.toSet

  private val predicateGeneratingCounter = new AtomicInteger(0)

  final private val subgoalAtoms
    : CachingFunction[ /* query-connected */ Set[ /* query-bound */ Variable], Atom] =
    CachingFunction { (variableSet: Set[Variable]) =>
      // by the contract, we can (and should) reject variable sets that
      //  - are not connected, or
      //  - contain non-bound variables
      if (!boundVariableConnectedQuery.connects(variableSet))
        throw new IllegalArgumentException(
          s"The given set of variables ($variableSet) is not connected in the given query ($boundVariableConnectedQuery)."
        )

      if (!variableSet.subsetOf(queryBoundVariables))
        throw new IllegalArgumentException(
          s"The given set of variables ($variableSet) contains non-bound variables in the given query ($boundVariableConnectedQuery)."
        )

      val neighbourhood = boundVariableConnectedQuery.strictNeighbourhoodOf(variableSet)

      val symbol =
        s"${intentionalPredicatePrefix}_${predicateGeneratingCounter.getAndIncrement}"
      val subgoalPredicate = Predicate.create(symbol, neighbourhood.size)

      Atom.create(subgoalPredicate, neighbourhood.sortBySymbol: _*)
    }

  /**
   * Computes an atom corresponding to the given connected set of variables in a query, while
   * storing any generated atom to the cache for future use.
   *
   * On generation of an atom, the predicate symbol of the atom is generated by concatenating
   * `intentionalPredicatePrefix` with an internal integer counter.
   *
   * @throws IllegalArgumentException
   *   if the given set of variables is disconnected or contains free variables.
   */
  def apply(variableSet: Set[Variable]): Atom =
    this.subgoalAtoms.apply(variableSet)
}
